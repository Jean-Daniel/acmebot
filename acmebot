#!/usr/bin/env python3

# Certificate manager using ACME protocol
#
# To install on Debian:
# apt-get install build-essential libssl-dev libffi-dev python3-dev python3-pip
# pip3 install acme py3dns

import os
import sys
import argparse
import json
import time
import datetime
import re
import subprocess
import collections
import tempfile
import pwd
import grp
import heapq
import hashlib
import base64
import pkg_resources
import binascii

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa, ec
from cryptography.hazmat.primitives.serialization import Encoding, PublicFormat, PrivateFormat, NoEncryption

import OpenSSL

from acme import client
from acme import messages
from acme import jose

import DNS

DNSTuple = collections.namedtuple('DNSTuple', ['datetime', 'name_server', 'domain_name', 'response', 'attempt_count'])
AuthorizationTuple = collections.namedtuple('AuthorizationTuple', ['datetime', 'authorization_resource'])
KeyData = collections.namedtuple('KeyData', ['key', 'timestamp'])
PrivateKeyData = collections.namedtuple('PrivateKeyData', ['name', 'key_options', 'keys', 'backup_keys',
                                                           'generated_key', 'rolled_key', 'issued_certificates'])
CertificateData = collections.namedtuple('CertificateData', ['certificate_name', 'key_type', 'certificate', 'chain', 'config'])
TLSAData = collections.namedtuple('TLSAData', ['host', 'port', 'usage', 'selector', 'protocol', 'ttl',
                                               'certificates', 'chain', 'private_keys'])

class AcmeError(Exception):
    pass

class FileTransaction(object):
    __slots__ = ['file', 'temp_file_path', 'file_path', 'chmod', 'timestamp']

    def __init__(self, file_path, chmod=None, timestamp=None):
        self.file_path = file_path
        self.chmod = chmod
        self.timestamp = timestamp
        temp_file_descriptor, self.temp_file_path = tempfile.mkstemp()
        self.file = open(temp_file_descriptor, 'w')

    def __del__(self):
        if (self.file):
            self.file.close()
            self.file = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if (self.file):
            self.file.close()

    def write(self, data):
        self.file.write(data)

class AcmeManager(object):
    @classmethod
    def Run(cls):
        try:
            manager = cls()
            manager.run()
            del manager
        except AcmeError as error:
            pass

    def __init__(self):
        script_dir = os.path.dirname(os.path.realpath(__file__))
        self.script_name = os.path.basename(__file__)
        self.script_version = '1.1'

        argparser = argparse.ArgumentParser(description='ACME Certificate Manager')
        argparser.add_argument('--version', action='version', version='%(prog)s ' + self.script_version)
        argparser.add_argument('private_key_names', nargs = '*')
        argparser.add_argument('-q', '--quiet',
                               action='store_true', dest='quiet', default=False,
                               help="Don't print status messages to stdout or warnings to stderr")
        argparser.add_argument('-d', '--debug',
                               action='store_true', dest='debug', default=False,
                               help='Print detailed debugging information to stdout')
        argparser.add_argument('-v', '--verbose',
                               action='store_true', dest='verbose', default=False,
                               help='Print more detailed debugging information to stdout')
        argparser.add_argument('-c', '--config',
                               dest='config_path', default=self.script_name+'.json', metavar='CONFIG_PATH',
                               help='Specify file path for config')
        argparser.add_argument('-r', '--rollover',
                               action='store_true', dest='rollover', default=False,
                               help='Rollover private keys and Diffie-Hellman parameters')
        argparser.add_argument('-F', '--force',
                               action='store_true', dest='force_rollover', default=False,
                               help='Force rollover for keys within HPKP window')
        argparser.add_argument('-R', '--renew',
                               action='store_true', dest='renew', default=False,
                               help='Renew certificate regardless of age')
        argparser.add_argument('-K', '--revoke',
                               action='store_true', dest='revoke', default=False,
                               help='Revoke certificate')
        argparser.add_argument('-a', '--auth',
                               action='store_true', dest='auth', default=False,
                               help='Update authorizations only')
        argparser.add_argument('-t', '--tlsa',
                               action='store_true', dest='tlsa', default=False,
                               help='Update TLSA records only')
        self.args = argparser.parse_args()

        if (self.args.debug):
            sys.excepthook = debug_hook

        self.authorizations = {}

        self.config, self.config_file_path = self._load_config(self.args.config_path, ('.', os.path.join('/etc', self.script_name), script_dir))
        self._key_types = ('rsa', 'ecdsa')
        self._settings_defaults = {
            'slave_mode': False,
            'key_size': 4096,
            'key_curve': 'secp384r1',
            'dhparam_size': 2048,
            'ecparam_curve': 'secp384r1',
            'file_user': 'root',
            'file_group': 'ssl-cert',
            'hpkp_days': 30,
            'pin_subdomains': True,
            'renewal_days': 30,
            'expiration_days': 730,
            'auto_rollover': False,
            'max_dns_lookup_attempts': 30,
            'dns_lookup_delay': 10,
            'max_authorization_attempts': 30,
            'authorization_delay': 10,
            'acme_directory_url': 'https://acme-v01.api.letsencrypt.org/directory',
            'reload_zone_command': '/etc/bind/reload-zone.sh',
            'nsupdate_command': '/usr/bin/nsupdate'
        }
        self._directory_defaults = {
            'pid': '/var/run',
            'resource': os.path.join('/var/local', self.script_name),
            'private_key': '/etc/ssl/private',
            'certificate': '/etc/ssl/certs',
            'chain': '/etc/ssl/certs',
            'param': '/etc/ssl/private',
            'challenge': '/etc/ssl/challenges',
            'hpkp': '/etc/ssl/hpkp',
            'update_key': '/etc/ssl/update_keys',
            'archive': '/etc/ssl/archive'
        }
        self._key_type_suffix_defaults = {
            'rsa': '.rsa',
            'ecdsa': '.ecdsa'
        }

        self.resource_dir = os.path.join(script_dir, self._directory('resource'))
        os.makedirs(self.resource_dir, exist_ok = True)

    def _load_config(self, file_path, search_paths=[]):
        search_paths = [''] if (os.path.isabs(file_path)) else search_paths
        for search_path in search_paths:
            config_file_path = os.path.join(search_path, file_path)
            if (os.path.isfile(config_file_path)):
                try:
                    with open(config_file_path) as config_file:
                        return (json.load(config_file, object_pairs_hook=collections.OrderedDict), os.path.abspath(config_file_path))
                except Exception as error:
                    self._error('Error reading config file ', config_file_path, ': ', error, '\n')
        self._error('Config file ', file_path, ' not found\n')

    def _message(self, *args):
        message = ''
        for arg in args:
            message += str(arg, 'utf-8', 'replace') if isinstance(arg, bytes) else str(arg)
        return message

    def _status(self, *args):
        if (not self.args.quiet):
            sys.stdout.write(self._message(*args))

    def _debug(self, *args):
        if ((self.args.debug or self.args.verbose) and not self.args.quiet):
            sys.stdout.write(self._message(*args))

    def _note(self, *args):
        if (self.args.verbose and not self.args.quiet):
            sys.stdout.write(self._message(*args))

    def _warn(self, *args):
        if (not self.args.quiet):
            sys.stderr.write(self._message(*args))

    def _error(self, *args):
        message = self._message(*args)
        sys.stderr.write(message)
        raise AcmeError(message)

    def _open_file(self, file_path, mode='r', chmod=0o777):
        def opener(file_path, flags):
            return os.open(file_path, flags, mode=chmod)
        if (('w' in mode) and isinstance(file_path, str)):
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
        return open(file_path, mode, opener=opener)

    def _archive_file(self, file_path, archive_name='', archive_date=datetime.datetime.now()):
        if (os.path.isfile(file_path) and (not os.path.islink(file_path)) and (archive_name is not None)):
            archive_file_path = os.path.join(self._directory('archive'),
                                             archive_name,
                                             archive_date.strftime('%Y_%m_%d_%H%M%S') if (archive_date) else '',
                                             os.path.basename(file_path))
            os.makedirs(os.path.dirname(archive_file_path), exist_ok=True)
            os.rename(file_path, archive_file_path)
            self._note('Archived ', file_path, ' as ', archive_file_path, '\n')
            return (file_path, archive_file_path)
        return (None, None)

    def _get_user_id(self, user_name):
        try:
            return pwd.getpwnam(user_name).pw_uid
        except:
            return -1

    def _get_group_id(self, group_name):
        try:
            return grp.getgrnam(group_name).gr_gid
        except:
            return -1

    def _rename_file(self, old_file_path, new_file_path, chmod=None, timestamp=None, archive_name=''):
        old_file_path = old_file_path.replace('*', '_')
        new_file_path = new_file_path.replace('*', '_')
        if (os.path.isfile(old_file_path)):
            self._archive_file(new_file_path, archive_name=archive_name)
            os.makedirs(os.path.dirname(new_file_path), exist_ok=True)
            os.rename(old_file_path, new_file_path)
            if (chmod):
                os.chmod(new_file_path, chmod)
            if (timestamp):
                os.utime(new_file_path, (timestamp, timestamp))
            try:
                os.chown(new_file_path, self._get_user_id(self._settings('file_user')), self._get_group_id(self._settings('file_group')))
            except PermissionError as error:
                self._warn('Unable to set file ownership for ', new_file_path, '\n', error, '\n')

    def _commit_file_transactions(self, file_transactions, archive_name=''):
        archived_files = []
        try:
            if (archive_name is not None):
                archive_date = datetime.datetime.now()
                for file_transaction in file_transactions:
                    archived_files.append(self._archive_file(file_transaction.file_path, archive_name=archive_name, archive_date=archive_date))
            for file_transaction in file_transactions:
                self._rename_file(file_transaction.temp_file_path, file_transaction.file_path,
                                  chmod=file_transaction.chmod, timestamp=file_transaction.timestamp, archive_name=None)
        except Exception as error:  # restore any archived files
            for original_file_path, archived_file_path in archived_files:
                if (original_file_path):
                    os.rename(archived_file_path, original_file_path)
            raise error

    def _account(self, key):
        return self.config.get('account', {}).get(key, '')

    def _settings(self, key):
        return self.config.get('settings', self._settings_defaults).get(key, self._settings_defaults.get(key))

    def _directory(self, key):
        return self.config.get('directories', self._directory_defaults).get(key, self._directory_defaults.get(key))

    def _key_type_suffix(self, key_type):
        return self.config.get('key_type_suffix', self._key_type_suffix_defaults).get(key_type, self._key_type_suffix_defaults.get(key_type))

    def _challenge_file_path(self, file_name, file_extension=''):
        return os.path.join(self._directory('challenge'), file_name + file_extension)

    def _datetime_from_asn1_generaltime(self, general_time):
        try:
            return datetime.datetime.strptime(general_time.decode('ascii'), '%Y%m%d%H%M%SZ')
        except ValueError:
            return datetime.datetime.strptime(general_time.decode('ascii'), '%Y%m%d%H%M%S%z')

    def _http_challenge_directory(self, domain_name):
        return self.config.get('http_challenges', {}).get(domain_name, None)

    def _zone_key(self, zone_name):
        key_data = self.config.get('zone_update_keys', {}).get(zone_name, None)
        if (key_data):
            if (isinstance(key_data, str)):
                return { 'file': os.path.join(self._directory('update_key'), key_data) }
            if ('file' in key_data):
                key_data = key_data.copy()
                key_data['file'] = os.path.join(self._directory('update_key'), key_data['file'])
                return key_data
        return None

    def _get_challenge(self, authorization_resource, type):
        for challenge in authorization_resource.body.challenges:
            if (type == challenge.typ):
                return challenge
        return None

    def _get_domain_names(self, zone_dict, zone_name):
        domain_names = []
        for host_name in zone_dict[zone_name]:
            host_name = host_name.strip().lower()
            domain_names.append(zone_name if ('@' == host_name) else (host_name + '.' + zone_name))
        return domain_names

    def _reload_zone(self, zone_name):
        try:
            output = subprocess.check_output([self._settings('reload_zone_command'), zone_name], stderr=subprocess.STDOUT)
            self._debug('Reloading zone ', zone_name, '\n')
            time.sleep(2)
        except subprocess.CalledProcessError as error:
            self._error('Failed to reload zone ', zone_name, ', code: ', error.returncode, '\n', error.output, '\n')
        except Exception as error:
            self._error('Failed to reload zone ', zone_name, '\n', error, '\n')

    def _get_primary_name_server(self, zone_name):
        try:
            response = DNS.Request().req(name=zone_name, qtype='SOA')
            if ('NOERROR' == response.header['status']):
                return response.answers[0]['data'][0]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        self._warn('Unable to find primary name server for ', zone_name, ' ', response.header.status, '\n')
        return None

    def _get_name_servers(self, zone_name):
        try:
            response = DNS.Request().req(name=zone_name, qtype='NS')
            if ('NOERROR' == response.header['status']):
                return [answer['data'] for answer in response.answers]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        self._warn('Unable to find name servers for ', zone_name, ' ', response.header.status, '\n')
        return []

    def _lookup_dns_challenge(self, name_server, domain_name):
        try:
            response = DNS.Request(server=name_server).req(name='_acme-challenge.' + domain_name, qtype='TXT')
            if ('NOERROR' == response.header['status']):
                return [answer['data'][0].decode('ascii') for answer in response.answers]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return []

    def _lookup_tlsa_records(self, name_server, host, port, protocol):
        try:
            response = DNS.Request(server=name_server).req(name='_{port}._{protocol}.{host}'.format(port=port, protocol=protocol, host=host), qtype=52, protocol='tcp')
            if ('NOERROR' == response.header['status']):
                return ['{} {} {} {}'.format(answer['data'][0], answer['data'][1], answer['data'][2], binascii.hexlify(answer['data'][3:]).decode('ascii'))
                         for answer in response.answers]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return []

    def _update_zone(self, updates, zone_name, zone_key, operation):
        server = 'server {server} {port}\n'.format(server=zone_key['server'], port=zone_key.get('port', '')) if ('server' in zone_key) else ''
        update_commands = '{server}zone {zone}\n{update}\nsend\n'.format(server=server, zone=zone_name, update='\n'.join(updates))
        try:
            self._note('nsupdate:\n', update_commands)
            output = subprocess.check_output([self._settings('nsupdate_command'), '-v', '-k', zone_key['file']],
                                             input=update_commands.encode('ascii'), stderr=subprocess.STDOUT)
            self._debug(operation, ' records for ', zone_name, '\n')
            return True
        except subprocess.CalledProcessError as error:
            self._warn(operation, ' records failed for ', zone_name, ', code: ', error.returncode, '\n', error.output, '\n')
        except Exception as error:
            self._warn(operation, ' records failed for ', zone_name, '\n', error, '\n')
        return False

    def _set_dns_challenges(self, zone_name, zone_key, challenges):
        updates = ['update add _acme-challenge.{host} 300 TXT "{challenge}"'.format(host=host_name, challenge=challenges[host_name])
                    for host_name in challenges]
        return self._update_zone(updates, zone_name, zone_key, 'Set DNS challenges')

    def _remove_dns_challenges(self, zone_name, zone_key, challenges):
        updates = ['update delete _acme-challenge.{host} 300 TXT "{challenge}"'.format(host=host_name, challenge=challenges[host_name])
                    for host_name in challenges]
        self._update_zone(updates, zone_name, zone_key, 'Remove DNS challenges')

    def _tlsa_data(self, records, certificates=None, chain=[], private_keys=None):
        data = []
        for record in records:
            if (isinstance(record, str)):
                record = { 'host': record }
            data.append(TLSAData(record.get('host', '@'), record.get('port', 443),
                                 record.get('usage', 'pkix-ee'), record.get('selector', 'spki'),
                                 record.get('protocol', 'tcp'), record.get('ttl', 300),
                                 certificates, chain, private_keys))
        return data

    def _set_tlsa_records(self, zone_name, zone_key, tlsa_records):
        usage = { 'pkix-ta': '0', 'pkix-ee': '1', 'dane-ta': '2', 'dane-ee': '3' }
        selector = { 'cert': '0', 'spki': '1' }
        updates = []
        name_server = self._get_primary_name_server(zone_name)
        for tlsa_data in tlsa_records:
            host_name = zone_name if ('@' == tlsa_data.host) else (tlsa_data.host + '.' + zone_name)
            if (tlsa_data.usage in usage):
                usage_id = usage[tlsa_data.usage]
            else:
                self._warn('Unknown TLSA usage ', tlsa_data.usage, '\n')
                usage_id = usage['pkix-ee']
            if ('cert' == tlsa_data.selector):
                if (tlsa_data.usage in ('pkix-ee', 'dane-ee')):
                    certificates = [self._certificate_bytes(certificate) for certificate in tlsa_data.certificates]
                else:
                    certificates = [self._certificate_bytes(certificate) for certificate in tlsa_data.chain]
                keys = []
            else:
                certificates = []
                if (tlsa_data.usage in ('pkix-ee', 'dane-ee')):
                    keys = [self._public_key_bytes(private_key) for private_key in tlsa_data.private_keys]
                else:
                    keys = [self._certificate_public_key_bytes(certificate) for certificate in tlsa_data.chain]

            record_name = '_{port}._{protocol}.{host}.'.format(host=host_name, port=tlsa_data.port, protocol=tlsa_data.protocol)
            records = []
            record_bytes = set()
            for certificate_bytes in certificates:
                if (certificate_bytes and certificate_bytes not in record_bytes):   # dedupe chain certificates (may be shared between key types)
                    record_bytes.add(certificate_bytes)
                    records.append('{usage} 0 1 {digest}'.format(usage=usage_id, digest=hashlib.sha256(certificate_bytes).hexdigest()))
                    records.append('{usage} 0 2 {digest}'.format(usage=usage_id, digest=hashlib.sha512(certificate_bytes).hexdigest()))
            for key_bytes in keys:
                if (key_bytes and key_bytes not in record_bytes):   # dedupe chain certificates (may be shared between key types)
                    record_bytes.add(key_bytes)
                    records.append('{usage} 1 1 {digest}'.format(usage=usage_id, digest=hashlib.sha256(key_bytes).hexdigest()))
                    records.append('{usage} 1 2 {digest}'.format(usage=usage_id, digest=hashlib.sha512(key_bytes).hexdigest()))

            if (set(records) == set(self._lookup_tlsa_records(name_server, host_name, tlsa_data.port, tlsa_data.protocol))):
                self._note('TLSA records already present for ', record_name, '\n')
                continue

            updates.append('update delete {record_name} {ttl} TLSA'.format(record_name=record_name, ttl=tlsa_data.ttl))
            for record in records:
                updates.append('update add {record_name} {ttl} TLSA {record}'.format(record_name=record_name, record=record, ttl=tlsa_data.ttl))
        if (updates):
            self._update_zone(updates, zone_name, zone_key, 'Set TLSA')

    def _remove_tlsa_records(self, zone_name, zone_key, tlsa_records):
        updates = []
        for tlsa_data in tlsa_records:
            host_name = zone_name if ('@' == tlsa_data.host) else (tlsa_data.host + '.' + zone_name)
            updates.append('update delete _{port}._{proto}.{host}. TLSA'.format(port=tlsa_data.port, proto=tlsa_data.protocol, host=host_name))
        self._update_zone(updates, zone_name, zone_key, 'Remove TLSA')

    def _reload_service(self, service_name):
        service_commands = self.config.get('services', {})
        if (service_name in service_commands):
            self._debug('Reloading service ', service_name, '\n')
            try:
                output = subprocess.check_output(service_commands[service_name], shell=True, stderr=subprocess.STDOUT)
                if (output):
                    self._warn('Service ', service_name, ' responded to reload with:\n', output, '\n')
            except subprocess.CalledProcessError as error:
                self._warn('Service ', service_name, ' reload failed, code: ', error.returncode, '\n', error.output, '\n')
        else:
            self._warn('Service ', service_name, ' does not have registered reload command\n')

    def generate_rsa_key(self, key_size):
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, key_size)
        return key

    def generate_ecdsa_key(self, key_curve):
        key_curve = key_curve.lower()
        if ('secp256r1' == key_curve):
            key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        elif ('secp384r1' == key_curve):
            key = ec.generate_private_key(ec.SECP384R1(), default_backend())
        elif ('secp521r1' == key_curve):
            key = ec.generate_private_key(ec.SECP521R1(), default_backend())
        else:
            self._warn('Unsupported key curve: ', key_curve, '\n')
            return None
#        return OpenSSL.crypto.PKey.from_cryptography_key(key)  # currently not supported
        key_pem = key.private_bytes(encoding=Encoding.PEM, format=PrivateFormat.TraditionalOpenSSL, encryption_algorithm=NoEncryption())
        return OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_pem)

    def generate_private_key(self, key_type, options):
        if ('rsa' == key_type):
            return self.generate_rsa_key(*options)
        if ('ecdsa' == key_type):
            return self.generate_ecdsa_key(*options)
        self._warn('Unknown key type ', key_type, '\n')
        return None

    def _private_key_file_path(self, file_name, key_type, file_extension='.key'):
        return os.path.join(self._directory('private_key'), file_name + self._key_type_suffix(key_type) + file_extension)

    def load_private_key(self, file_name, key_type):
        try:
            file_path = self._private_key_file_path(file_name, key_type)
            with open(file_path, 'r') as private_key_file:
                return KeyData(OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, private_key_file.read().encode('ascii')), os.stat(file_path).st_mtime)
        except:
            return KeyData(None, None)

    def save_private_key(self, file_name, key_type, private_key, timestamp=None, certificate=None, chain=[], dhparam_pem=None, ecparam_pem=None):
        with FileTransaction(self._private_key_file_path(file_name, key_type), 0o640, timestamp) as transaction:
            if (private_key):
                transaction.write(OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, private_key).decode('ascii'))
                if (certificate):
                    transaction.write('\n')
                    self._save_certificate(transaction, certificate, chain=chain, dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem)
        return transaction

    def archive_private_key(self, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file(self._private_key_file_path(file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _time_to_rollover(self, backup_key_timestamp, expiration_days):
        if (backup_key_timestamp and expiration_days):
            backup_key_modified_time = datetime.datetime.fromtimestamp(backup_key_timestamp)
            return (expiration_days < (datetime.datetime.now() - backup_key_modified_time).days)
        return False

    def _safe_to_rollover(self, backup_key_timestamp, hpkp_days):
        if (backup_key_timestamp and hpkp_days):
            backup_key_modified_time = datetime.datetime.fromtimestamp(backup_key_timestamp)
            return (hpkp_days < (datetime.datetime.now() - backup_key_modified_time).days)
        return True

    def _public_key_bytes(self, private_key):
        if (private_key):
            return private_key.to_cryptography_key().public_key().public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
        return None

    def _certificate_public_key_bytes(self, certificate):
        if (certificate):
            return certificate.get_pubkey().to_cryptography_key().public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
        return None

    def _public_key_digest(self, private_key, digest='sha256'):
         if ('sha256' == digest):
             return hashlib.sha256(self._public_key_bytes(private_key)).digest()
         return hashlib.sha512(self._public_key_bytes(private_key)).digest()

    def _certificate_bytes(self, certificate):
        if (certificate):
            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, certificate.wrapped)
        return None

    def _hpkp_file_path(self, file_name, file_extension):
        return os.path.join(self._directory('hpkp'), file_name + file_extension)

    def hpkp_headers_present(self, file_name):
        return (os.path.isfile(self._hpkp_file_path(file_name, '.nginx'))
                and os.path.isfile(self._hpkp_file_path(file_name, '.apache')))

    def save_hpkp_headers(self, file_name, private_keys, hpkp_days, pin_subdomains):
        pins = '; '.join([('pin-sha256=\\"' + base64.b64encode(self._public_key_digest(private_key)).decode('ascii') + '\\"') for private_key in private_keys])
        duration = str(hpkp_days * 86400)
        sub_domains = ' includeSubdomains;' if (pin_subdomains) else ''
        header = '{pins}; max-age={duration};{sub_domains}'.format(pins=pins, duration=duration, sub_domains=sub_domains)

        with FileTransaction(self._hpkp_file_path(file_name, '.nginx'), 0o644) as nginx_transaction:
            nginx_transaction.write('add_header Public-Key-Pins "{header}";\n'.format(header=header))

        with FileTransaction(self._hpkp_file_path(file_name, '.apache'), 0o644) as apache_transaction:
            apache_transaction.write('Header always set Public-Key-Pins "{header}"\n'.format(header=header))

        return nginx_transaction, apache_transaction

    def archive_hpkp_headers(self, file_name, archive_name='', archive_date=None):
        self._archive_file(self._hpkp_file_path(file_name, '.nginx'), archive_name=archive_name, archive_date=archive_date)
        self._archive_file(self._hpkp_file_path(file_name, '.apache'), archive_name=archive_name, archive_date=archive_date)

    def get_alt_names(self, certificate):
        for index in range(certificate.get_extension_count()):
            extension = certificate.get_extension(index)
            if (b'subjectAltName' == extension.get_short_name()):
                return [alt_name.split(':')[1] for alt_name in str(extension).split(', ')]
        return []

    def _private_key_matches_certificate(self, private_key, certificate):
        return self._public_key_bytes(private_key) == self._certificate_public_key_bytes(certificate)

    def _certificate_digest(self, certificate, digest='sha256'):
        return certificate.wrapped.digest(digest).decode('ascii').replace(':','').lower()

    def _certificate_file_path(self, file_name, key_type, file_extension='.pem'):
        return os.path.join(self._directory('certificate'), file_name + self._key_type_suffix(key_type) + file_extension)

    def load_certificate(self, file_name, key_type):
        try:
            with open(self._certificate_file_path(file_name, key_type), 'r') as certificate_file:
                return jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate_file.read().encode('ascii')))
        except:
            return None

    def save_certificate(self, file_name, key_type, certificate, chain=[], root_certificate=None, dhparam_pem=None, ecparam_pem=None):
        with FileTransaction(self._certificate_file_path(file_name, key_type), 0o644) as transaction:
            self._save_certificate(transaction.file, certificate, chain=chain, root_certificate=root_certificate, dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem)
        return transaction

    def archive_certificate(self, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file(self._certificate_file_path(file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _save_certificate(self, certificate_file, certificate, chain=None, root_certificate=None, dhparam_pem=None, ecparam_pem=None):
        certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate.wrapped).decode('ascii')
        certificate_not_before = self._datetime_from_asn1_generaltime(certificate.get_notBefore())
        certificate_file.write(certificate.get_subject().commonName + ' issued at ' + certificate_not_before.strftime('%Y-%m-%d %H:%M:%S UTC') + '\n')
        certificate_file.write(certificate_pem)
        if (chain):
            self._save_chain(certificate_file, chain, '\n')
        if (root_certificate):
            root_certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, root_certificate.wrapped).decode('ascii')
            certificate_file.write('\n' + root_certificate.get_subject().commonName + '\n')
            certificate_file.write(root_certificate_pem)
        if (dhparam_pem):
            certificate_file.write('\n' + dhparam_pem)
        if (ecparam_pem):
            certificate_file.write('\n' + ecparam_pem)

    def _chain_file_path(self, file_name, key_type, file_extension='.pem'):
        return os.path.join(self._directory('chain'), file_name + '_chain' + self._key_type_suffix(key_type) + file_extension)

    def load_chain(self, file_name, key_type):
        chain = []
        try:
            chain_file_path = self._chain_file_path(file_name, key_type)
            if (os.path.isfile(chain_file_path)):
                with open(chain_file_path) as chain_file:
                    pem_data = chain_file.read()
                    index = 0
            else:
                with open(self._certificate_file_path(file_name, key_type)) as certificate_file:
                    pem_data = certificate_file.read()
                    index = 1
            certificate_pems = re.findall('-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----', pem_data, re.DOTALL)[index:]
            for certificate_pem in certificate_pems:
                chain.append(jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate_pem.encode('ascii'))))
        except:
            pass
        return chain

    def save_chain(self, file_name, key_type, chain):
        with FileTransaction(self._chain_file_path(file_name, key_type), 0o644) as transaction:
            self._save_chain(transaction.file, chain)
        return transaction

    def archive_chain(self, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file(self._chain_file_path(file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _save_chain(self, chain_file, chain, lead_in=''):
        for chain_certificate in chain:
            chain_certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, chain_certificate.wrapped).decode('ascii')
            chain_file.write(lead_in + chain_certificate.get_subject().commonName + '\n')
            chain_file.write(chain_certificate_pem)
            lead_in = '\n'

    def generate_dhparam(self, dhparam_size):
        try:
            return subprocess.check_output(['openssl', 'dhparam', str(dhparam_size)], stderr=subprocess.DEVNULL).decode('ascii') if (dhparam_size) else None
        except:
            return None

    def generate_ecparam(self, ecparam_curve):
        try:
            return subprocess.check_output(['openssl', 'ecparam', '-name', ecparam_curve], stderr=subprocess.DEVNULL).decode('ascii') if (ecparam_curve) else None
        except:
            return None

    def _param_file_path(self, file_name, file_extension='.pem'):
        return os.path.join(self._directory('param'), file_name + '_param' + file_extension)

    def params_present(self, file_name):
        return os.path.isfile(self._param_file_path(file_name))

    def load_params(self, file_name):
        try:
            param_file_path = self._param_file_path(file_name)
            if (os.path.isfile(param_file_path)):
                with open(param_file_path) as param_file:
                    pem_data = param_file.read()
            else:
                for key_type in self._key_types:
                    certificate_file_path = self._certificate_file_path(file_name, key_type)
                    if (os.path.isfile(certificate_file_path)):
                        with open(certificate_file_path) as certificate_file:
                            pem_data = certificate_file.read()
                        break
            if (pem_data):
                match = re.match(r'.*(-----BEGIN DH PARAMETERS-----.*-----END DH PARAMETERS-----)', pem_data, re.DOTALL)
                dhparam_pem = (match.group(1) + '\n') if (match) else None
                match = re.match(r'.*(-----BEGIN EC PARAMETERS-----.*-----END EC PARAMETERS-----)', pem_data, re.DOTALL)
                ecparam_pem = (match.group(1) + '\n') if (match) else None
                return (dhparam_pem, ecparam_pem)
        except:
            pass
        return (None, None)

    def save_params(self, file_name, dhparam_pem, ecparam_pem):
        with FileTransaction(self._param_file_path(file_name), 0o640) as transaction:
            if (dhparam_pem and ecparam_pem):
                transaction.write(dhparam_pem + '\n' + ecparam_pem)
            else:
                transaction.write(dhparam_pem or ecparam_pem)
        return transaction

    def archive_params(self, file_name, archive_name='', archive_date=None):
        self._archive_file(self._param_file_path(file_name), archive_name=archive_name, archive_date=archive_date)

    def generate_csr(self, private_key, common_name, alt_names=[], must_staple=False):
        req = OpenSSL.crypto.X509Req()
        req.get_subject().CN = common_name
        extensions = [
            OpenSSL.crypto.X509Extension(
                b'subjectAltName',
                critical=False,
                value=', '.join('DNS:%s' % domain_name for domain_name in alt_names).encode('ascii')
            )
        ]
        if (must_staple):
            extensions.append(OpenSSL.crypto.X509Extension(
                b'1.3.6.1.5.5.7.1.24',
                critical=False,
                value=b'DER:30:03:02:01:05'))
        req.add_extensions(extensions)
        req.set_version(2)
        req.set_pubkey(private_key)
        req.sign(private_key, 'sha256')
        return req

    def _validate_certificates(self):
        private_keys = self.config.get('private_keys', collections.OrderedDict())
        if ('certificates' in self.config): # convert bare certificate definitions to private key definitions
            certificates = self.config['certificates']
            for certificate_name in certificates:
                if (certificate_name not in private_keys):
                    private_keys[certificate_name] = collections.OrderedDict()
                if ('certificates' not in private_keys[certificate_name]):
                    private_keys[certificate_name]['certificates'] = collections.OrderedDict()
                if (certificate_name not in private_keys[certificate_name]['certificates']):
                    for config_key in ('key_types', 'key_size', 'key_curve', 'expiration_days', 'auto_rollover', 'hpkp_days', 'pin_subdomains'):
                        if ((config_key in certificates[certificate_name]) and (config_key not in private_keys[certificate_name])):
                            private_keys[certificate_name][config_key] = certificates[certificate_name][config_key]
                            del certificates[certificate_name][config_key]
                    private_keys[certificate_name]['certificates'][certificate_name] = certificates[certificate_name]
                else:
                    self._error('Certificate ', certificate_name, ' already configured with private key\n')
            del self.config['certificates']

        for private_key_name in private_keys:
            key_certificates = private_keys[private_key_name].get('certificates', {})
            if (not key_certificates):
                self._error('No certificates defined for private key ', private_key_name, '\n')
            certificate_key_types = set()
            for certificate_name in key_certificates:
                for zone_name in key_certificates[certificate_name].get('alt_names', {}):
                    common_name = key_certificates[certificate_name].get('common_name', certificate_name)
                    if (common_name in self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name)):
                        break
                else:
                    self._error('Certificate common name "', common_name, '" not listed in alt_names\n')
                certificate_key_types |= set(key_certificates[certificate_name].get('key_types', self._key_types))
            key_options = self._get_key_options(private_key_name)
            private_keys[private_key_name]['key_types'] = [key_type for key_type in key_options if (key_type in certificate_key_types)]
        self.config['private_keys'] = private_keys

    def connect_client(self):
        client_key_path = os.path.join(self.resource_dir, 'client_key.json')
        if (os.path.isfile(client_key_path)):
            with open(client_key_path) as client_key_file:
                self.client_key = jose.JWKRSA.fields_from_json(json.load(client_key_file))
                self._note('Loaded clent key ', client_key_path, '\n')
        else:
            self._status('Client key not present, generating\n')
            self.client_key = jose.JWKRSA(key=rsa.generate_private_key(public_exponent=65537, key_size=4096, backend=default_backend()))
            with self._open_file(client_key_path, 'w', 0o600) as client_key_file:
                json.dump(self.client_key.fields_to_partial_json(), client_key_file)
                self._note('Saved client key ', client_key_path, '\n')

        try:
            user_agent = '{script}/{version} acme-python/{acme_version}'.format(script=self.script_name, version=self.script_version,
                             acme_version=pkg_resources.get_distribution('acme').version)
            network = client.ClientNetwork(self.client_key, user_agent=user_agent)
            self.acme_client = client.Client(self._settings('acme_directory_url'), self.client_key, net=network)
        except Exception as error:
            self._error("Can't connect to ACME service.\n", error, '\n')

        registration_path = os.path.join(self.resource_dir, 'registration.json')
        if (os.path.isfile(registration_path)):
            with open(registration_path) as registration_file:
                self.registration = messages.RegistrationResource.json_loads(registration_file.read())
                self._note('Loaded registration ', registration_path, '\n')

            self.registration = self.acme_client.query_registration(self.registration)
        else:
            self._note('Registering client\n')
            self.registration = self.acme_client.register(messages.NewRegistration.from_data(email=self._account('email')))
            self._note('Auto-accepting TOS: ', self.registration.terms_of_service, '\n')
            self.acme_client.agree_to_tos(self.registration)
            self.registration = self.acme_client.query_registration(self.registration)   # get agreement info
        with FileTransaction(registration_path, 0o600) as transaction:
            transaction.write(self.registration.json_dumps())
            self._note('Saved registration ', registration_path, '\n')
        self._commit_file_transactions([transaction], archive_name=None)

    def process_authorizations(self, private_key_names=[]):
        private_keys = self.config.get('private_keys', {})
        authorizations = self.config.get('authorizations', {})

        domain_challenges = {}
        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue
            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                for zone_name in key_certificates[certificate_name]['alt_names']:
                    if (zone_name not in domain_challenges):
                        domain_challenges[zone_name] = []
                    for domain_name in self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name):
                        if (domain_name not in domain_challenges[zone_name]):
                            domain_challenges[zone_name].append(domain_name)

        if (not self._settings('slave_mode')):
            for zone_name in authorizations:
                if (zone_name not in domain_challenges):
                    domain_challenges[zone_name] = []
                for domain_name in self._get_domain_names(authorizations, zone_name):
                    if (domain_name not in domain_challenges[zone_name]):
                        domain_challenges[zone_name].append(domain_name)

        # get authorizations
        authorization_resources = {}
        for zone_name in domain_challenges:
            for domain_name in domain_challenges[zone_name]:
                self._debug('Request authorization for ', domain_name, '\n')
                authorization_resource = self.acme_client.request_domain_challenges(domain_name, new_authzr_uri=self.registration.new_authzr_uri)
                if (messages.STATUS_VALID == authorization_resource.body.status):
                    self.authorizations[domain_name] = authorization_resource
                    self._debug(domain_name, ' already authorized\n')
                elif (messages.STATUS_PENDING == authorization_resource.body.status):
                    if (not self._settings('slave_mode')):
                        authorization_resources[domain_name] = authorization_resource
                    else:
                        self._debug(domain_name, ' not authorized\n')
                else:
                    self._error('Unexpected status "', authorization_resource.body.status, '" for authorization of ', domain_name, '\n')

        # set challenge responses
        challenge_types = {}
        challenge_dns_responses = {}
        challenge_http_responses = {}
        for zone_name in domain_challenges:
            zone_responses = {}
            for domain_name in domain_challenges[zone_name]:
                if (domain_name in authorization_resources):
                    http_challenge_directory = self._http_challenge_directory(domain_name)
                    if (http_challenge_directory):
                        challenge_types[domain_name] = 'http-01'
                        challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
                        challenge_file_path = os.path.join(http_challenge_directory, challenge.chall.encode('token'))
                        self._debug('Setting http acme-challenge for ', domain_name, ' in file ', challenge_file_path, '\n')
                        try:
                            with self._open_file(challenge_file_path, 'w', 0o644) as challenge_file:
                                challenge_file.write(challenge.validation(self.client_key))
                            challenge_http_responses[domain_name] = challenge_file_path
                        except Exception as error:
                            self._warn('Unable to create acme-challenge file ', challenge_file_path, '\n', error, '\n')
                    else:
                        challenge_types[domain_name] = 'dns-01'
                        challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
                        zone_responses[domain_name] = challenge.validation(self.client_key)
                        self._debug('Setting DNS for _acme-challenge.', domain_name, ' = "', zone_responses[domain_name], '"\n')
            if (zone_responses):
                zone_key = self._zone_key(zone_name)
                if (zone_key):
                    if (self._set_dns_challenges(zone_name, zone_key, zone_responses)):
                        challenge_dns_responses[zone_name] = zone_responses
                else:
                    try:
                        with self._open_file(self._challenge_file_path(zone_name), 'w', 0o644) as challenge_file:
                            json.dump(zone_responses, challenge_file);
                        challenge_dns_responses[zone_name] = zone_responses
                    except Exception as error:
                        self._warn('Unable to create acme-challenge file for zone ', zone_name, '\n', error, '\n')
                    if (zone_name in challenge_dns_responses):
                        self._reload_zone(zone_name)

        # wait for DNS propagation
        waiting = []
        for zone_name in challenge_dns_responses:
            name_servers = self._get_name_servers(zone_name)
            self._note('Got name servers ', name_servers, ' for ', zone_name, '\n')
            for name_server in name_servers:
                waiting += [DNSTuple(datetime.datetime.now(), name_server, domain_name, challenge_dns_responses[zone_name][domain_name], 0)
                                for domain_name in challenge_dns_responses[zone_name]]
        while waiting:
            when, name_server, domain_name, response, attempt_count = heapq.heappop(waiting)
            now = datetime.datetime.now()
            if (now < when):
                seconds = (when - now).seconds
                if (0 < seconds):
                    time.sleep(seconds)
            dns_challenges = self._lookup_dns_challenge(name_server, domain_name)
            if (response in dns_challenges):
                self._debug('Challenge present for ', domain_name, ' at ', name_server, '\n')
            else:
                self._note('Challenge missing for ', domain_name, ' at ', name_server, '\n')
                if (attempt_count < self._settings('max_dns_lookup_attempts')):
                    heapq.heappush(waiting, DNSTuple(datetime.datetime.now() + datetime.timedelta(seconds=self._settings('dns_lookup_delay')),
                                                     name_server, domain_name, response, attempt_count + 1))
                else:
                    self._warn('Maximum attempts reached waiting for DNS challenge ', domain_name, ' at ', name_server, '\n')
        if (challenge_dns_responses):
            time.sleep(2)

        # answer challenges
        for domain_name in authorization_resources:
            self._debug('Answering challenge for ', domain_name, '\n')
            challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
            self.acme_client.answer_challenge(challenge, challenge.response(self.client_key))

        # poll for authorizations
        waiting = [AuthorizationTuple(datetime.datetime.now(), authorization_resource) for authorization_resource in authorization_resources.values()]
        attempts = collections.defaultdict(int)
        exhausted = []
        failed = []
        while waiting:
            when, authorization_resource = heapq.heappop(waiting)
            now = datetime.datetime.now()
            if (now < when):
                seconds = (when - now).seconds
                if (0 < seconds):
                    time.sleep(seconds)
            self._debug('Polling for ', authorization_resource.body.identifier.value, '\n')
            authorization_resource, response = self.acme_client.poll(authorization_resource)
            if (200 != response.status_code):
                self._warn(response, ' while waiting for domain challenge\n')
                heapq.heappush(waiting, AuthorizationTuple(
                    self.acme_client.retry_after(response, default=self._settings('authorization_delay')),
                    authorization_resource))
                continue

            attempts[authorization_resource] += 1
            if (messages.STATUS_VALID == authorization_resource.body.status):
                self.authorizations[authorization_resource.body.identifier.value] = authorization_resource
                self._debug('Authorization received\n')
                continue
            elif (messages.STATUS_INVALID == authorization_resource.body.status):
                self._debug('Invalid authorization: ', self._get_challenge(authorization_resource, challenge_types[domain_name]).error.detail, '\n')
                failed.append(authorization_resource)
            elif (messages.STATUS_PENDING == authorization_resource.body.status):
                if (self._settings('max_authorization_attempts') < attempts[authorization_resource]):
                    exhausted.append(authorization_resource)
                    self._note('Giving up\n')
                else:
                    self._note('Retrying\n')
                    heapq.heappush(waiting, AuthorizationTuple(
                        self.acme_client.retry_after(response, default=self._settings('authorization_delay')),
                        authorization_resource))
            else:
                self._error('Unexpected status "', authorization_resource.body.status, '"\n')

        # clear challenge responses
        for zone_name in challenge_dns_responses:
            self._debug('Removing DNS _acme-challenges for ', zone_name, '\n')
            zone_key = self._zone_key(zone_name)
            if (zone_key):
                self._remove_dns_challenges(zone_name, zone_key, challenge_dns_responses[zone_name])
            else:
                os.remove(self._challenge_file_path(zone_name))
                self._reload_zone(zone_name)
        for domain_name in challenge_http_responses:
            self._debug('Removing http acme-challenge for ', domain_name, '\n')
            os.remove(challenge_http_responses[domain_name])

        for authorization_resource in failed:
            self._status('Authorization failed for ', authorization_resource.body.identifier.value, '\n')
        for authorization_resource in exhausted:
            self._status('Authorization timed out for ', authorization_resource.body.identifier.value, '\n')

    def _get_key_options(self, private_key_name):
        private_keys = self.config.get('private_keys', {})
        key_size = private_keys[private_key_name].get('key_size', self._settings('key_size'))
        key_curve = private_keys[private_key_name].get('key_curve', self._settings('key_curve'))
        key_types = private_keys[private_key_name].get('key_types', self._key_types)
        key_options = {}
        if (key_size and ('rsa' in key_types)):
            key_options['rsa'] = (key_size, )
        if (key_curve and ('ecdsa' in key_types)):
            key_options['ecdsa'] = (key_curve, )
        return key_options

    def process_certificates(self, private_key_names=[]):
        private_keys = self.config.get('private_keys', {})
        updated_key_zones = set()
        updated_services = set()
        processed_keys = []

        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue

            self._debug('Processing private key ', private_key_name, '\n')

            key_options = self._get_key_options(private_key_name)
            if (not key_options):
                self._warn('No configured private key types for ', private_key_name, '\n')
                continue

            hpkp_days = private_keys[private_key_name].get('hpkp_days', self._settings('hpkp_days'))
            expiration_days = private_keys[private_key_name].get('expiration_days', self._settings('expiration_days'))

            rolled_private_key = False
            generated_private_key = False

            backup_keys = {}
            youngest_key_timestamp = datetime.datetime.max.timestamp()
            oldest_key_timestamp = 0
            for key_type in key_options:
                backup_key_data = self.load_private_key(private_key_name + '_backup', key_type)
                if (backup_key_data.timestamp):
                    youngest_key_timestamp = min(youngest_key_timestamp, backup_key_data.timestamp)
                    oldest_key_timestamp = max(oldest_key_timestamp, backup_key_data.timestamp)
                backup_keys[key_type] = backup_key_data

            rollover = False
            if (self.args.rollover
                 or (private_keys[private_key_name].get('auto_rollover', self._settings('auto_rollover'))
                     and self._time_to_rollover(oldest_key_timestamp, expiration_days))):
                if (self.args.force_rollover or self._safe_to_rollover(youngest_key_timestamp, hpkp_days)):
                    rollover = True
                else:
                    self._warn('Backup private key for ', private_key_name, ' is younger than HPKP duration, rollover skipped\n',
                                'Use "--force" to force key rollover, note that this can brick a web site if HPKP is deployed\n')

            if (rollover):
                keys = {key_type: KeyData(None, None) for key_type in key_options}
            else:
                keys = {key_type: self.load_private_key(private_key_name, key_type) for key_type in key_options}

            for key_type in key_options:
                if (backup_keys[key_type].key and not keys[key_type].key):
                    keys[key_type] = backup_keys[key_type]
                    backup_keys[key_type] = KeyData(None, None)
                    rolled_private_key = True
            if (rolled_private_key):
                self._status('Private key rolled over for ', private_key_name, '\n')

            if (self._time_to_rollover(oldest_key_timestamp, expiration_days) and private_key
                and not rolled_private_key and self._safe_to_rollover(youngest_key_timestamp, hpkp_days)):
                self._status('Backup key for ', private_key_name, ' has expired. Use "--rollover" to replace.\n')

            for key_type, options in key_options.items():
                if (not keys[key_type].key):
                    self._status('Generating primary ', key_type, ' key for ', private_key_name, '\n')
                    private_key = self.generate_private_key(key_type, options)
                    keys[key_type] = KeyData(private_key, None)
                    if (private_key):
                        generated_private_key = True

            for key_type, key_data in keys.items():
                if (not key_data.key):
                    del key_options[key_type]

            issued_certificates = []
            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                self._debug('Processing certificate ', certificate_name, '\n')

                alt_names = []
                for zone_name in key_certificates[certificate_name]['alt_names']:
                    alt_names += self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name)

                missing_authorizations = [alt_name for alt_name in alt_names if (alt_name not in self.authorizations)]
                if (missing_authorizations):
                    self._status('Unable to issue certificate ', certificate_name, ' due to missing authorization(s) for: ', ', '.join(missing_authorizations), '\n')
                    if (rolled_private_key):
                        issued_certificates = []    # do not partially install new certificates if private key changed
                        break
                    continue

                common_name = key_certificates[certificate_name].get('common_name', certificate_name)
                certificate_key_types = key_certificates[certificate_name].get('key_types', key_options.keys())
                for key_type in certificate_key_types:
                    if ((key_type not in keys) or (not keys[key_type].key)):
                        self._warn('No ', key_type, ' private key available for certificate ', certificate_name, '\n')
                        continue

                    if ((not rolled_private_key) and (not self.args.renew)):
                        existing_certificate = self.load_certificate(certificate_name, key_type)
                        if (existing_certificate):
                            certificate_common_name = existing_certificate.get_subject().commonName
                            if (common_name != certificate_common_name):
                                self._status('Common name changed for ', certificate_name, ' from ', certificate_common_name, ' to ', common_name, '\n')
                            else:
                                certificate_alt_names = self.get_alt_names(existing_certificate)
                                new_alt_names = set(alt_names)
                                existing_alt_names = set(certificate_alt_names)
                                if (new_alt_names != existing_alt_names):
                                    added_alt_names = new_alt_names - existing_alt_names
                                    removed_alt_names = existing_alt_names - new_alt_names
                                    self._status('Alt names changed for ', certificate_name,
                                                 (', adding ' + ', '.join([alt_name for alt_name in alt_names if (alt_name in added_alt_names)])) if added_alt_names else '',
                                                 (', removing ' + ', '.join([alt_name for alt_name in certificate_alt_names if (alt_name in removed_alt_names)])) if removed_alt_names else '',
                                                 '\n')
                                else:
                                    if (not self._private_key_matches_certificate(keys[key_type].key, existing_certificate)):
                                        self._status('Certificate ', certificate_name, ' public key does not match private key\n')
                                    else:
                                        valid_duration = self._datetime_from_asn1_generaltime(existing_certificate.get_notAfter()) - datetime.datetime.now()
                                        if (valid_duration.days < 0):
                                            self._status('Existing certificate ', certificate_name, ' has expired\n')
                                        elif (valid_duration.days < self._settings('renewal_days')):
                                            self._status('Existing certificate ', certificate_name, ' will expire in ',
                                                         (str(valid_duration.days) + ' days') if (valid_duration.days) else 'less than a day',
                                                         '\n')
                                        else:
                                            self._debug('Certificate valid beyond renewal window\n')
                                            continue

                    csr = self.generate_csr(keys[key_type].key, common_name, alt_names)
                    self._status('Requesting ', key_type, ' certificate for ', common_name, (' with alt names: ' + ', '.join(alt_names)) if (alt_names) else '', '\n')
                    try:
                        certificate_resource = self.acme_client.request_issuance(jose.ComparableX509(csr),
                                                                                 [self.authorizations[domain_name] for domain_name in alt_names])
                    except Exception as error:
                        self._warn('Certificate issuance failed\n', error, '\n')
                        if (rolled_private_key):
                            issued_certificates = []    # do not partially install new certificates if private key changed
                            break
                        continue

                    self._debug('New certificate issued\n')
                    chain = self.acme_client.fetch_chain(certificate_resource)
                    issued_certificates.append(CertificateData(certificate_name, key_type, certificate_resource.body, chain, key_certificates[certificate_name]))

            if (issued_certificates):
                processed_keys.append(PrivateKeyData(private_key_name, key_options, keys, backup_keys,
                                                     generated_private_key, rolled_private_key, issued_certificates))


        # install keys and certificates
        root_certificates = {}
        for key_type in self._key_types:
            root_certificates[key_type] = self.load_certificate(os.path.join(os.path.dirname(self.config_file_path), 'root_cert'), key_type)

        for private_key_data in processed_keys:
            private_key_name = private_key_data.name

            generated_backup_key = False
            backup_keys = private_key_data.backup_keys
            for key_type, options in private_key_data.key_options.items():
                if (not backup_keys[key_type].key):
                    self._status('Generating backup ', key_type, ' key for ', private_key_name, '\n')
                    backup_keys[key_type] = KeyData(self.generate_private_key(key_type, options), None)
                    generated_backup_key = True

            transactions = []

            for key_type in private_key_data.key_options:
                if (private_key_data.generated_key or private_key_data.rolled_key):
                    transactions.append(self.save_private_key(private_key_name, key_type,
                                                              private_key_data.keys[key_type].key, timestamp=private_key_data.keys[key_type].timestamp))
                if (generated_backup_key):
                    transactions.append(self.save_private_key(private_key_name + '_backup', key_type,
                                                              backup_keys[key_type].key, timestamp=backup_keys[key_type].timestamp))

            hpkp_days = private_keys[private_key_name].get('hpkp_days', self._settings('hpkp_days'))
            if ((0 < hpkp_days) and (self._directory('hpkp'))
                    and (private_key_data.generated_key or generated_backup_key or not self.hpkp_headers_present(private_key_name))):
                keys = ([private_key_data.keys[key_type].key for key_type in private_key_data.key_options if private_key_data.keys[key_type].key]
                        + [private_key_data.backup_keys[key_type].key for key_type in private_key_data.key_options if private_key_data.backup_keys[key_type].key])
                if (1 < len(keys)):
                    transactions += self.save_hpkp_headers(private_key_name, keys, hpkp_days,
                                                           private_keys[private_key_name].get('pin_subdomains', self._settings('pin_subdomains')))

            processed_params = set()
            for certificate_data in private_key_data.issued_certificates:
                certificate_name = certificate_data.certificate_name
                if (certificate_name not in processed_params):
                    processed_params.add(certificate_name)

                    generated_params = False
                    dhparam_pem, ecparam_pem = self.load_params(certificate_name) if (not private_key_data.rolled_key) else (None, None)
                    if (not dhparam_pem):
                        dhparam_size = certificate_data.config.get('dhparam_size', self._settings('dhparam_size'))
                        if (dhparam_size):
                            self._status('Generating Diffie-Hellman parameters for ', certificate_name, '\n')
                            dhparam_pem = self.generate_dhparam(dhparam_size)
                            generated_params = True
                    if (not ecparam_pem):
                        ecparam_curve = certificate_data.config.get('ecparam_curve', self._settings('ecparam_curve'))
                        if (ecparam_curve):
                            self._status('Generating elliptical curve parameters for ', certificate_name, '\n')
                            ecparam_pem = self.generate_ecparam(ecparam_curve)
                            generated_params = True

                    if ((dhparam_pem or ecparam_pem) and self._directory('param') and (generated_params or not self.params_present(certificate_name))):
                        transactions.append(self.save_params(certificate_name, dhparam_pem, ecparam_pem))

                key_type = certificate_data.key_type
                transactions.append(self.save_certificate(certificate_name, key_type, certificate_data.certificate, chain=certificate_data.chain,
                                                          dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))
                if (root_certificates[key_type]):
                    transactions.append(self.save_certificate(certificate_name + '+root', key_type, certificate_data.certificate,
                                                              chain=certificate_data.chain, root_certificate=root_certificates[key_type],
                                                              dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))
                if (certificate_data.chain and self._directory('chain')):
                    transactions.append(self.save_chain(certificate_name, key_type, certificate_data.chain))
                transactions.append(self.save_private_key(certificate_name + '_full', key_type, private_key_data.keys[key_type].key,
                                                          certificate=certificate_data.certificate, chain=certificate_data.chain,
                                                          dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))

            try:
                self._commit_file_transactions(transactions, archive_name=private_key_name)
                if (private_key_data.generated_key or private_key_data.rolled_key or generated_backup_key):
                    self._status('Private keys for ', private_key_name, ' installed\n')
                for certificate_data in private_key_data.issued_certificates:
                    certificate_name = certificate_data.certificate_name
                    self._status('Certificate ', certificate_name, ' (', certificate_data.key_type, ') installed\n')
                    updated_services.update(certificate_data.config.get('services', []))
                    if (not self._settings('slave_mode')):
                        for zone_name in certificate_data.config['alt_names']:
                            if (not self._zone_key(zone_name)):
                                updated_key_zones.add(zone_name)
            except Exception as error:
                self._warn('Unable to install keys and certificates for ', private_key_name, '\n', error, '\n')

        for zone_name in updated_key_zones:
            self._reload_zone(zone_name)
        for service_name in updated_services:
            self._reload_service(service_name)

    def revoke_certificates(self, private_key_names):
        private_keys = self.config.get('private_keys', {})
        updated_key_zones = set()
        updated_tlsa_zones = collections.OrderedDict()

        for private_key_name in private_key_names:
            if (private_key_name in private_keys):
                key_options = self._get_key_options(private_key_name)
                if (not key_options):
                    self._warn('No configured private key types for ', private_key_name, '\n')
                    continue

                key_certificates = private_keys[private_key_name].get('certificates', {})
                revoked_certificates = []
                certificate_count = 0
                for certificate_name in key_certificates:
                    certificate_key_types = key_certificates[certificate_name].get('key_types', key_options.keys())
                    for key_type in certificate_key_types:
                        certificate = self.load_certificate(certificate_name, key_type)
                        if (certificate):
                            certificate_count += 1
                            try:
                                self.acme_client.revoke(certificate)
                                revoked_certificates.append((certificate_name, key_type))
                                self._status('Certificate ', certificate_name, ' (', key_type, ') revoked\n')
                            except Exception as error:
                                self._warn('Unable to revoke certificate ', certificate_name, ' (', key_type, ')\n', error, '\n')
                        else:
                            self._warn('Certificate ', certificate_name, ' (', key_type, ') not found\n')

                archive_date = datetime.datetime.now()
                processed_tlsa = set()
                for certificate_name, key_type in revoked_certificates:
                    self.archive_certificate(certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_certificate(certificate_name + '+root', key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_chain(certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_private_key(certificate_name + '_full', key_type, archive_name=private_key_name, archive_date=archive_date)

                    if (not self._settings('slave_mode')):
                        for zone_name in key_certificates[certificate_name]['alt_names']:
                            if (not self._zone_key(zone_name)):
                                updated_key_zones.add(zone_name)
                    if (certificate_name not in processed_tlsa):
                        processed_tlsa.add(certificate_name)

                        tlsa_records = key_certificates[certificate_name].get('tlsa_records', {})
                        for zone_name in tlsa_records:
                            if (self._zone_key(zone_name)):
                                if (zone_name not in updated_tlsa_zones):
                                    updated_tlsa_zones[zone_name] = []
                                updated_tlsa_zones[zone_name] += self._tlsa_data(tlsa_records[zone_name])
                            else:
                                self._warn('No update key configured for zone ', zone_name, ' unable to remove TLSA records\n')

                if (len(revoked_certificates) == certificate_count):
                    for key_type in key_options:
                        self.archive_private_key(private_key_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                        self.archive_hpkp_headers(private_key_name, archive_name=private_key_name, archive_date=archive_date)
                        self.archive_params(certificate_name, archive_name=private_key_name, archive_date=archive_date)
            else:
                self._warn(private_key_name, ' is not a configured private key\n')

        for zone_name in updated_key_zones:
            self._reload_zone(zone_name)
        for zone_name in updated_tlsa_zones:
            self._remove_tlsa_records(zone_name, self._zone_key(zone_name), updated_tlsa_zones[zone_name])

    def update_tlsa_records(self, private_key_names):
        private_keys = self.config.get('private_keys', {})
        tlsa_zones = collections.OrderedDict()

        root_certificates = []
        for key_type in self._key_types:
            root_certificates.append(self.load_certificate(os.path.join(os.path.dirname(self.config_file_path), 'root_cert'), key_type))

        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue

            key_options = self._get_key_options(private_key_name)
            if (not key_options):
                self._warn('No configured private key types for ', private_key_name, '\n')
                continue

            keys = []
            for key_type in key_options:
                keys.append((key_type, self.load_private_key(private_key_name, key_type).key))
                keys.append((key_type, self.load_private_key(private_key_name + '_backup', key_type).key))

            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                tlsa_records = key_certificates[certificate_name].get('tlsa_records', {})
                if (tlsa_records):
                    certificates = []
                    chain = []
                    certificate_key_types = key_certificates[certificate_name].get('key_types', key_options.keys())
                    for key_type in certificate_key_types:
                        certificates.append(self.load_certificate(certificate_name, key_type))
                        chain += self.load_chain(certificate_name, key_type)

                    for zone_name in tlsa_records:
                        if (self._zone_key(zone_name)):
                            if (zone_name not in tlsa_zones):
                                tlsa_zones[zone_name] = []
                            tlsa_zones[zone_name] += self._tlsa_data(tlsa_records[zone_name], certificates=certificates,
                                                                     chain=(chain + root_certificates),
                                                                     private_keys=[key for key_type, key in keys if (key_type in certificate_key_types)])
                        else:
                            self._warn('No update key configured for zone ', zone_name, ' unable to set TLSA records\n')

        for zone_name in tlsa_zones:
            self._set_tlsa_records(zone_name, self._zone_key(zone_name), tlsa_zones[zone_name])

    def _process_running(self, pid_file_path):
        try:
            with open(pid_file_path) as pid_file:
                return (-1 < os.getsid(int(pid_file.read())))
        except:
            pass
        return False

    def run(self):
        self._validate_certificates()
        pid_file_path = os.path.join(self._directory('pid'), self.script_name + '.pid')
        if (self._process_running(pid_file_path)):
            self._error('Client already running\n')
        with self._open_file(pid_file_path, 'w') as pid_file:
            pid_file.write(str(os.getpid()))
        try:
            self.connect_client()
            if (self.args.revoke):
                if (not self.args.private_key_names):
                    self._error('Revocation must explicitly specify private key names\n')
                else:
                    self.revoke_certificates(self.args.private_key_names)
            elif (self.args.auth):
                self.process_authorizations(self.args.private_key_names)
            elif (self.args.tlsa):
                self.update_tlsa_records(self.args.private_key_names)
            else:
                self.process_authorizations(self.args.private_key_names)
                self.process_certificates(self.args.private_key_names)
                self.update_tlsa_records(self.args.private_key_names)
            del self.acme_client
        finally:
            os.remove(pid_file_path)



def debug_hook(type, value, tb):
   if hasattr(sys, 'ps1') or not sys.stderr.isatty():
      # we are in interactive mode or we don't have a tty-like
      # device, so we call the default hook
      sys.__excepthook__(type, value, tb)
   else:
      import traceback, pdb
      # we are NOT in interactive mode, print the exception...
      traceback.print_exception(type, value, tb)
      print()
      # ...then start the debugger in post-mortem mode.
      pdb.pm()


if __name__ == '__main__':      # called from the command line
    AcmeManager.Run()

