#!/usr/bin/env python3

# Certificate manager using ACME protocol
#
# To install on Debian:
# apt-get install build-essential libssl-dev libffi-dev python3-dev python3-pip
# pip3 install -r requirements.txt

import argparse
import base64
import binascii
import collections
import datetime
import getpass
import grp
import hashlib
import heapq
import json
import os
import pwd
import re
import struct
import subprocess
import sys
import tempfile
import time
import urllib

import DNS

import OpenSSL

from acme import client, jose, messages

from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import ec, rsa
from cryptography.hazmat.primitives.serialization import Encoding, NoEncryption, PrivateFormat, PublicFormat

import pkg_resources


DNSTuple = collections.namedtuple('DNSTuple', ['datetime', 'name_server', 'domain_name', 'response', 'attempt_count'])
AuthorizationTuple = collections.namedtuple('AuthorizationTuple', ['datetime', 'authorization_resource'])
KeyData = collections.namedtuple('KeyData', ['key', 'timestamp'])
SCTData = collections.namedtuple('SCTData', ['version', 'id', 'timestamp', 'extensions', 'signature'])
PrivateKeyData = collections.namedtuple('PrivateKeyData', ['name', 'key_options', 'keys', 'backup_keys',
                                                           'generated_key', 'rolled_key', 'changed_key', 'issued_certificates'])
KeyCipherData = collections.namedtuple('KeyCipherData', ['cipher', 'passphrase', 'forced'])
CertificateData = collections.namedtuple('CertificateData', ['certificate_name', 'key_type', 'certificate', 'chain', 'config'])
TLSAData = collections.namedtuple('TLSAData', ['host', 'port', 'usage', 'selector', 'protocol', 'ttl',
                                               'certificates', 'chain', 'private_keys'])


class AcmeError(Exception):
    pass


class PrivateKeyError(Exception):
    pass


class FileTransaction(object):
    __slots__ = ['file', 'temp_file_path', 'file_type', 'file_path', 'chmod', 'timestamp']

    def __init__(self, file_type, file_path, chmod=None, timestamp=None, mode='w'):
        self.file_type = file_type
        self.file_path = file_path
        self.chmod = chmod
        self.timestamp = timestamp
        temp_file_descriptor, self.temp_file_path = tempfile.mkstemp()
        self.file = open(temp_file_descriptor, mode)

    def __del__(self):
        if (self.file):
            self.file.close()
            self.file = None

    def __enter__(self):
        return self

    def __exit__(self, type, value, traceback):
        if (self.file):
            self.file.close()

    def write(self, data):
        self.file.write(data)


class AcmeManager(object):
    @classmethod
    def Run(cls):
        try:
            manager = cls()
            manager.run()
            del manager
        except AcmeError:
            pass

    def __init__(self):
        self.script_dir = os.path.dirname(os.path.realpath(__file__))
        self.script_name = os.path.basename(__file__)
        self.script_version = '1.4'

        argparser = argparse.ArgumentParser(description='ACME Certificate Manager')
        argparser.add_argument('--version', action='version', version='%(prog)s ' + self.script_version)
        argparser.add_argument('private_key_names', nargs='*')
        argparser.add_argument('-q', '--quiet',
                               action='store_true', dest='quiet', default=False,
                               help="Don't print status messages to stdout or warnings to stderr")
        argparser.add_argument('-d', '--debug',
                               action='store_true', dest='debug', default=False,
                               help='Print detailed debugging information to stdout')
        argparser.add_argument('-v', '--verbose',
                               action='store_true', dest='verbose', default=False,
                               help='Print more detailed debugging information to stdout')
        argparser.add_argument('-c', '--config',
                               dest='config_path', default=self.script_name + '.json', metavar='CONFIG_PATH',
                               help='Specify file path for config')
        argparser.add_argument('-r', '--rollover',
                               action='store_true', dest='rollover', default=False,
                               help='Rollover private keys and Diffie-Hellman parameters')
        argparser.add_argument('-F', '--force',
                               action='store_true', dest='force_rollover', default=False,
                               help='Force rollover for keys within HPKP window')
        argparser.add_argument('-R', '--renew',
                               action='store_true', dest='renew', default=False,
                               help='Renew certificate regardless of age')
        argparser.add_argument('-K', '--revoke',
                               action='store_true', dest='revoke', default=False,
                               help='Revoke certificate')
        argparser.add_argument('-a', '--auth',
                               action='store_true', dest='auth', default=False,
                               help='Update authorizations only')
        argparser.add_argument('-t', '--tlsa',
                               action='store_true', dest='tlsa', default=False,
                               help='Update TLSA records only')
        argparser.add_argument('-s', '--sct',
                               action='store_true', dest='sct', default=False,
                               help='Update Signed Certificate Timestamps only')
        argparser.add_argument('-p', '--pass', nargs=1, default=False,
                               action='store', dest='passphrase', metavar='PASSPHRASE',
                               help='Passphrase for private keys')
        self.args = argparser.parse_args()

        if (self.args.debug):
            sys.excepthook = debug_hook

        self.authorizations = {}
        self.key_passphrases = {}
        self.updated_services = set()

        self.config, self.config_file_path = self._load_config(self.args.config_path, ('.', os.path.join('/etc', self.script_name), self.script_dir))
        self._key_types = ('rsa', 'ecdsa')
        self._config_defaults = {
            'settings': {
                'slave_mode': False,
                'log_level': 'debug',
                'key_size': 4096,
                'key_curve': 'secp384r1',
                'key_cipher': 'blowfish',
                'key_passphrase': None,
                'dhparam_size': 2048,
                'ecparam_curve': 'secp384r1',
                'file_user': 'root',
                'file_group': 'ssl-cert',
                'hpkp_days': 30,
                'pin_subdomains': True,
                'hpkp_report_uri': None,
                'ocsp_must_staple': False,
                'ct_submit_logs': ['google_icarus'],
                'renewal_days': 30,
                'expiration_days': 730,
                'auto_rollover': False,
                'max_dns_lookup_attempts': 30,
                'dns_lookup_delay': 10,
                'max_authorization_attempts': 30,
                'authorization_delay': 10,
                'acme_directory_url': 'https://acme-v01.api.letsencrypt.org/directory',
                'reload_zone_command': '/etc/bind/reload-zone.sh',
                'nsupdate_command': '/usr/bin/nsupdate'
            },
            'directories': {
                'pid': '/var/run',
                'log': os.path.join('/var/log', self.script_name),
                'resource': os.path.join('/var/local', self.script_name),
                'private_key': '/etc/ssl/private',
                'backup_key': '/etc/ssl/private',
                'full_key': '/etc/ssl/private',
                'certificate': '/etc/ssl/certs',
                'full_certificate': '/etc/ssl/certs',
                'chain': '/etc/ssl/certs',
                'param': '/etc/ssl/params',
                'challenge': '/etc/ssl/challenges',
                'hpkp': '/etc/ssl/hpkp',
                'sct': '/etc/ssl/scts/{name}/{key_type}',
                'update_key': '/etc/ssl/update_keys',
                'archive': '/etc/ssl/archive'
            },
            'key_type_suffixes': {
                'rsa': '.rsa',
                'ecdsa': '.ecdsa'
            },
            'file_names': {
                'log': self.script_name + '.log',
                'private_key': '{name}{suffix}.key',
                'backup_key': '{name}_backup{suffix}.key',
                'full_key': '{name}_full{suffix}.key',
                'certificate': '{name}{suffix}.pem',
                'full_certificate': '{name}+root{suffix}.pem',
                'chain': '{name}_chain{suffix}.pem',
                'param': '{name}_param.pem',
                'challenge': '{name}',
                'hpkp': '{name}.{server}',
                'sct': '{ct_log_name}.sct'
            },
            'hpkp_headers': {
                'apache': 'Header always set Public-Key-Pins "{header}"\n',
                'nginx': 'add_header Public-Key-Pins "{header}";\n'
            },
            'services': {
                'apache': 'systemctl reload apache2',
                'coturn': 'systemctl restart coturn',
                'dovecot': 'systemctl restart dovecot',
                'etherpad': 'systemctl restart etherpad',
                'mysql': 'systemctl reload mysql',
                'nginx': 'systemctl reload nginx',
                'postfix': 'systemctl reload postfix',
                'postgresql': 'systemctl reload postgresql',
                'prosody': 'systemctl restart prosody',
                'synapse': 'systemctl restart matrix-synapse',
                'znc': 'systemctl restart znc'
            },
            'ct_logs': {
                'google_pilot': {
                    'url': 'https://ct.googleapis.com/pilot',
                    'id': 'pLkJkLQYWBSHuxOizGdwCjw1mAT5G9+443fNDsgN3BA='
                },
                'google_icarus': {
                    'url': 'https://ct.googleapis.com/icarus',
                    'id': 'KTxRllTIOWW6qlD8WAfUt2+/WHopctykwwz05UVH9Hg='
                },
                'google_rocketeer': {
                    'url': 'https://ct.googleapis.com/rocketeer',
                    'id': '7ku9t3XOYLrhQmkfq+GeZqMPfl+wctiDAMR7iXqo/cs='
                },
                'google_skydiver': {
                    'url': 'https://ct.googleapis.com/skydiver',
                    'id': 'u9nfvB+KcbWTlCOXqpJ7RzhXlQqrUugakJZkNo4e0YU='
                },
                'digicert': {
                    'url': 'https://ct1.digicert-ct.com/log',
                    'id': 'VhQGmi/XwuzT9eG9RLI+x0Z2ubyZEVzA75SYVdaJ0N0='
                },
                'symantec_ct': {
                    'url': 'https://ct.ws.symantec.com',
                    'id': '3esdK3oNT6Ygi4GtgWhwfi6OnQHVXIiNPRHEzbbsvsw='
                },
                'symantec_vega': {
                    'url': 'https://vega.ws.symantec.com',
                    'id': 'vHjh38X2PGhGSTNNoQ+hXwl5aSAJwIG08/aRfz7ZuKU='
                },
                'venafi': {
                    'url': 'https://ctlog.api.venafi.com',
                    'id': 'rDua7X+pZ0dXFZ5tfVdWcvnZgQCUHpve/+yhMTt1eC0='
                },
                'wosign': {
                    'url': 'https://ctlog.wosign.com',
                    'id': 'QbLcLonmPOSvG6e7Kb9oxt7m+fHMBH4w3/rjs7olkmM='
                },
                'cnnic': {
                    'url': 'https://ctserver.cnnic.cn',
                    'id': 'pXesnO11SN2PAltnokEInfhuD0duwgPC7L7bGF8oJjg='
                },
                'startssl': {
                    'url': 'https://ct.startssl.com',
                    'id': 'NLtq1sPfnAPuqKSZ/3iRSGydXlysktAfe/0bzhnbSO8='
                }
            }
        }

    def _load_config(self, file_path, search_paths=[]):
        search_paths = [''] if (os.path.isabs(file_path)) else search_paths
        for search_path in search_paths:
            config_file_path = os.path.join(search_path, file_path)
            if (os.path.isfile(config_file_path)):
                try:
                    with open(config_file_path) as config_file:
                        return (json.load(config_file, object_pairs_hook=collections.OrderedDict), os.path.abspath(config_file_path))
                except Exception as error:
                    self._error('Error reading config file ', config_file_path, ': ', error, '\n')
        self._error('Config file ', file_path, ' not found\n')

    def _message(self, *args):
        message = ''
        for arg in args:
            message += str(arg, 'utf-8', 'replace') if isinstance(arg, bytes) else str(arg)
        return message

    def _status(self, *args):
        if (not self.args.quiet):
            sys.stdout.write(self._message(*args))
        if (self._setting('log_level') in ['normal', 'debug', 'verbose']):
            self._log(*args)

    def _debug(self, *args):
        if ((self.args.debug or self.args.verbose) and not self.args.quiet):
            sys.stdout.write(self._message(*args))
        if (self._setting('log_level') in ['debug', 'verbose']):
            self._log(*args)

    def _note(self, *args):
        if (self.args.verbose and not self.args.quiet):
            sys.stdout.write(self._message(*args))
        if (self._setting('log_level') == 'verbose'):
            self._log(*args)

    def _warn(self, *args):
        if (not self.args.quiet):
            sys.stderr.write(self._message(*args))
        if (self._setting('log_level') in ['normal', 'debug', 'verbose']):
            self._log(*args)

    def _error(self, *args):
        message = self._message(*args)
        sys.stderr.write(message)
        self._log(message)
        raise AcmeError(message)

    def _log(self, *args):
        if (hasattr(self, 'config') and self._directory('log') and self._file_name('log') and self._setting('log_level')):
            log_file_path = self._file_path('log', self.script_name)
            try:
                with self._open_file(log_file_path, mode='a+', chmod=0o640, warn=False) as log_file:
                    log_file.write(self._message(*args))
            except Exception:
                sys.stderr.write('Unable to write to log file ' + log_file_path + '\n')

    def _makedir(self, dir_path, chmod=None, warn=True):
        if (not os.path.isdir(dir_path)):
            try:
                os.makedirs(dir_path)
                if (chmod):
                    if (chmod & 0o700):
                        chmod |= 0o100
                    if (chmod & 0o070):
                        chmod |= 0o010
                    if (chmod & 0o007):
                        chmod |= 0o001
                    try:
                        os.chmod(dir_path, chmod)
                    except PermissionError as error:
                        if (warn):
                            self._warn('Unable to set directory mode for ', dir_path, '\n', error, '\n')
            except Exception as error:
                if (warn):
                    self._warn('Unable to create directory ', dir_path, '\n', error, '\n')

    def _open_file(self, file_path, mode='r', chmod=0o777, warn=True):
        def opener(file_path, flags):
            return os.open(file_path, flags, mode=chmod)
        if ((('w' in mode) or ('a' in mode)) and isinstance(file_path, str)):
            self._makedir(os.path.dirname(file_path), chmod=chmod, warn=warn)
        return open(file_path, mode, opener=opener)

    def _archive_file(self, file_type, file_path, archive_name='', archive_date=datetime.datetime.now()):
        if (os.path.isfile(file_path) and (not os.path.islink(file_path)) and (archive_name is not None)):
            archive_file_path = os.path.join(self._directory('archive'),
                                             archive_name,
                                             archive_date.strftime('%Y_%m_%d_%H%M%S') if (archive_date) else '',
                                             file_type + '.' + os.path.basename(file_path))
            self._makedir(os.path.dirname(archive_file_path), 0o640)
            os.rename(file_path, archive_file_path)
            self._note('Archived ', file_path, ' as ', archive_file_path, '\n')
            return (file_path, archive_file_path)
        return (None, None)

    def _get_user_id(self, user_name):
        try:
            return pwd.getpwnam(user_name).pw_uid
        except Exception:
            return -1

    def _get_group_id(self, group_name):
        try:
            return grp.getgrnam(group_name).gr_gid
        except Exception:
            return -1

    def _rename_file(self, old_file_path, new_file_path, chmod=None, timestamp=None):
        old_file_path = old_file_path.replace('*', '_')
        new_file_path = new_file_path.replace('*', '_')
        if (os.path.isfile(old_file_path)):
            self._makedir(os.path.dirname(new_file_path), chmod)
            os.rename(old_file_path, new_file_path)
            if (chmod):
                try:
                    os.chmod(new_file_path, chmod)
                except PermissionError as error:
                    self._warn('Unable to set file mode for ', new_file_path, '\n', error, '\n')
            if (timestamp):
                try:
                    os.utime(new_file_path, (timestamp, timestamp))
                except PermissionError as error:
                    self._warn('Unable to set file time for ', new_file_path, '\n', error, '\n')
            try:
                os.chown(new_file_path, self._get_user_id(self._setting('file_user')), self._get_group_id(self._setting('file_group')))
            except PermissionError as error:
                self._warn('Unable to set file ownership for ', new_file_path, '\n', error, '\n')
            return new_file_path
        return None

    def _commit_file_transactions(self, file_transactions, archive_name=''):
        archived_files = []
        committed_files = []
        try:
            if (archive_name is not None):
                archive_date = datetime.datetime.now()
                for file_transaction in file_transactions:
                    archived_files.append(self._archive_file(file_transaction.file_type, file_transaction.file_path,
                                                             archive_name=archive_name, archive_date=archive_date))
            for file_transaction in file_transactions:
                committed_files.append(self._rename_file(file_transaction.temp_file_path, file_transaction.file_path,
                                                         chmod=file_transaction.chmod, timestamp=file_transaction.timestamp))
        except Exception as error:  # restore any archived files
            for committed_file_path in committed_files:
                if (committed_file_path):
                    os.remove(committed_file_path)
            for original_file_path, archived_file_path in archived_files:
                if (original_file_path):
                    os.rename(archived_file_path, original_file_path)
            raise error

    def _get_list(self, config, key, default=[]):
        value = config.get(key, default)
        return value if (isinstance(value, collections.Iterable) and not isinstance(value, str)) else [] if (value is None) else [value]

    def _config(self, section_name, key=None, default=None):
        return self.config.get(section_name, {}).get(key, default) if (key) else self.config.get(section_name, {})

    def _account(self, key):
        return self._config('account', key)

    def _setting(self, key):
        return self._config('settings', key)

    def _directory(self, file_type):
        return self._config('directories', file_type, '')

    def _key_type_suffix(self, key_type):
        return self._config('key_type_suffixes', key_type, '')

    def _file_name(self, file_type):
        return self._config('file_names', file_type, '')

    def _file_path(self, file_type, file_name, key_type=None, **kwargs):
        return os.path.join(self._directory(file_type).format(name=file_name, key_type=key_type, suffix=self._key_type_suffix(key_type), **kwargs),
                            self._file_name(file_type).format(name=file_name, key_type=key_type, suffix=self._key_type_suffix(key_type), **kwargs))

    def _service(self, service_name):
        return self._config('services', service_name)

    def _http_challenge_directory(self, domain_name):
        return self._config('http_challenges', domain_name)

    def _zone_key(self, zone_name):
        key_data = self._config('zone_update_keys', zone_name)
        if (key_data):
            if (isinstance(key_data, str)):
                return {'file': os.path.join(self._directory('update_key'), key_data)}
            if ('file' in key_data):
                key_data = key_data.copy()
                key_data['file'] = os.path.join(self._directory('update_key'), key_data['file'])
                return key_data
        return None

    def _option(self, config, key):
        return config.get(key, self._setting(key))

    def _option_list(self, config, key):
        value = config.get(key, self._setting(key))
        return value if (isinstance(value, collections.Iterable) and not isinstance(value, str)) else [] if (value is None) else [value]

    def _datetime_from_asn1_generaltime(self, general_time):
        try:
            return datetime.datetime.strptime(general_time.decode('ascii'), '%Y%m%d%H%M%SZ')
        except ValueError:
            return datetime.datetime.strptime(general_time.decode('ascii'), '%Y%m%d%H%M%S%z')

    def _get_challenge(self, authorization_resource, type):
        for challenge in authorization_resource.body.challenges:
            if (type == challenge.typ):
                return challenge
        return None

    def _get_domain_names(self, zone_dict, zone_name):
        domain_names = []
        for host_name in self._get_list(zone_dict, zone_name):
            host_name = host_name.strip().lower()
            domain_names.append(zone_name if ('@' == host_name) else (host_name + '.' + zone_name))
        return domain_names

    def _reload_zone(self, zone_name):
        try:
            subprocess.check_output([self._setting('reload_zone_command'), zone_name], stderr=subprocess.STDOUT)
            self._debug('Reloading zone ', zone_name, '\n')
            time.sleep(2)
        except subprocess.CalledProcessError as error:
            self._error('Failed to reload zone ', zone_name, ', code: ', error.returncode, '\n', error.output, '\n')
        except Exception as error:
            self._error('Failed to reload zone ', zone_name, '\n', error, '\n')

    def _get_primary_name_server(self, zone_name):
        try:
            response = DNS.Request().req(name=zone_name, qtype='SOA')
            if ('NOERROR' == response.header['status']):
                return response.answers[0]['data'][0]
            self._warn('Unable to find primary name server for ', zone_name, ' ', response.header['status'], '\n')
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return None

    def _get_name_servers(self, zone_name):
        try:
            response = DNS.Request().req(name=zone_name, qtype='NS')
            if ('NOERROR' == response.header['status']):
                return [answer['data'] for answer in response.answers]
            self._warn('Unable to find name servers for ', zone_name, ' ', response.header['status'], '\n')
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return []

    def _lookup_dns_challenge(self, name_server, domain_name):
        try:
            response = DNS.Request(server=name_server).req(name='_acme-challenge.' + domain_name, qtype='TXT')
            if ('NOERROR' == response.header['status']):
                return [answer['data'][0].decode('ascii') for answer in response.answers]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return []

    def _lookup_tlsa_records(self, name_server, host, port, protocol):
        try:
            response = DNS.Request(server=name_server).req(name='_{port}._{protocol}.{host}'.format(port=port, protocol=protocol, host=host),
                                                           qtype=52, protocol='tcp')
            if ('NOERROR' == response.header['status']):
                return ['{} {} {} {}'.format(answer['data'][0], answer['data'][1], answer['data'][2], binascii.hexlify(answer['data'][3:]).decode('ascii'))
                        for answer in response.answers]
        except Exception as error:
            self._note('DNS Error: ', error, '\n')
        return []

    def _update_zone(self, updates, zone_name, zone_key, operation):
        server = 'server {server} {port}\n'.format(server=zone_key['server'], port=zone_key.get('port', '')) if ('server' in zone_key) else ''
        update_commands = '{server}zone {zone}\n{update}\nsend\n'.format(server=server, zone=zone_name, update='\n'.join(updates))
        try:
            self._note('nsupdate:\n', update_commands)
            subprocess.check_output([self._setting('nsupdate_command'), '-v', '-k', zone_key['file']],
                                    input=update_commands.encode('ascii'), stderr=subprocess.STDOUT)
            self._debug(operation, ' records for ', zone_name, '\n')
            return True
        except subprocess.CalledProcessError as error:
            self._warn(operation, ' records failed for ', zone_name, ', code: ', error.returncode, '\n', error.output, '\n')
        except Exception as error:
            self._warn(operation, ' records failed for ', zone_name, '\n', error, '\n')
        return False

    def _set_dns_challenges(self, zone_name, zone_key, challenges):
        updates = ['update add _acme-challenge.{host} 300 TXT "{challenge}"'.format(host=host_name, challenge=challenges[host_name])
                   for host_name in challenges]
        return self._update_zone(updates, zone_name, zone_key, 'Set DNS challenges')

    def _remove_dns_challenges(self, zone_name, zone_key, challenges):
        updates = ['update delete _acme-challenge.{host} 300 TXT "{challenge}"'.format(host=host_name, challenge=challenges[host_name])
                   for host_name in challenges]
        self._update_zone(updates, zone_name, zone_key, 'Remove DNS challenges')

    def _tlsa_data(self, records, certificates=None, chain=[], private_keys=None):
        data = []
        for record in records:
            if (isinstance(record, str)):
                record = {'host': record}
            data.append(TLSAData(record.get('host', '@'), record.get('port', 443),
                                 record.get('usage', 'pkix-ee'), record.get('selector', 'spki'),
                                 record.get('protocol', 'tcp'), record.get('ttl', 300),
                                 certificates, chain, private_keys))
        return data

    def _set_tlsa_records(self, zone_name, zone_key, tlsa_records):
        usage = {'pkix-ta': '0', 'pkix-ee': '1', 'dane-ta': '2', 'dane-ee': '3'}
        updates = []
        name_server = self._get_primary_name_server(zone_name)
        if (not name_server):
            return
        for tlsa_data in tlsa_records:
            host_name = zone_name if ('@' == tlsa_data.host) else (tlsa_data.host + '.' + zone_name)
            if (tlsa_data.usage in usage):
                usage_id = usage[tlsa_data.usage]
            else:
                self._warn('Unknown TLSA usage ', tlsa_data.usage, '\n')
                usage_id = usage['pkix-ee']
            if ('cert' == tlsa_data.selector):
                if (tlsa_data.usage in ('pkix-ee', 'dane-ee')):
                    certificates = [self._certificate_bytes(certificate) for certificate in tlsa_data.certificates]
                else:
                    certificates = [self._certificate_bytes(certificate) for certificate in tlsa_data.chain]
                keys = []
            else:
                certificates = []
                if (tlsa_data.usage in ('pkix-ee', 'dane-ee')):
                    keys = [self._public_key_bytes(private_key) for private_key in tlsa_data.private_keys]
                else:
                    keys = [self._certificate_public_key_bytes(certificate) for certificate in tlsa_data.chain]

            record_name = '_{port}._{protocol}.{host}.'.format(host=host_name, port=tlsa_data.port, protocol=tlsa_data.protocol)
            records = []
            record_bytes = set()
            for certificate_bytes in certificates:
                if (certificate_bytes and certificate_bytes not in record_bytes):   # dedupe chain certificates (may be shared between key types)
                    record_bytes.add(certificate_bytes)
                    records.append('{usage} 0 1 {digest}'.format(usage=usage_id, digest=hashlib.sha256(certificate_bytes).hexdigest()))
                    records.append('{usage} 0 2 {digest}'.format(usage=usage_id, digest=hashlib.sha512(certificate_bytes).hexdigest()))
            for key_bytes in keys:
                if (key_bytes and key_bytes not in record_bytes):   # dedupe chain certificates (may be shared between key types)
                    record_bytes.add(key_bytes)
                    records.append('{usage} 1 1 {digest}'.format(usage=usage_id, digest=hashlib.sha256(key_bytes).hexdigest()))
                    records.append('{usage} 1 2 {digest}'.format(usage=usage_id, digest=hashlib.sha512(key_bytes).hexdigest()))

            if (set(records) == set(self._lookup_tlsa_records(name_server, host_name, tlsa_data.port, tlsa_data.protocol))):
                self._note('TLSA records already present for ', record_name, '\n')
                continue

            updates.append('update delete {record_name} {ttl} TLSA'.format(record_name=record_name, ttl=tlsa_data.ttl))
            for record in records:
                updates.append('update add {record_name} {ttl} TLSA {record}'.format(record_name=record_name, record=record, ttl=tlsa_data.ttl))
        if (updates):
            self._update_zone(updates, zone_name, zone_key, 'Set TLSA')

    def _remove_tlsa_records(self, zone_name, zone_key, tlsa_records):
        updates = []
        for tlsa_data in tlsa_records:
            host_name = zone_name if ('@' == tlsa_data.host) else (tlsa_data.host + '.' + zone_name)
            updates.append('update delete _{port}._{proto}.{host}. TLSA'.format(port=tlsa_data.port, proto=tlsa_data.protocol, host=host_name))
        self._update_zone(updates, zone_name, zone_key, 'Remove TLSA')

    def update_services(self, services):
        self.updated_services.update(services)

    def reload_services(self):
        for service_name in self.updated_services:
            service_command = self._service(service_name)
            if (service_command):
                self._debug('Reloading service ', service_name, '\n')
                try:
                    output = subprocess.check_output(service_command, shell=True, stderr=subprocess.STDOUT)
                    if (output):
                        self._warn('Service ', service_name, ' responded to reload with:\n', output, '\n')
                except subprocess.CalledProcessError as error:
                    self._warn('Service ', service_name, ' reload failed, code: ', error.returncode, '\n', error.output, '\n')
            else:
                self._warn('Service ', service_name, ' does not have registered reload command\n')

    def generate_rsa_key(self, key_size):
        key = OpenSSL.crypto.PKey()
        key.generate_key(OpenSSL.crypto.TYPE_RSA, key_size)
        return key

    def generate_ecdsa_key(self, key_curve):
        key_curve = key_curve.lower()
        if ('secp256r1' == key_curve):
            key = ec.generate_private_key(ec.SECP256R1(), default_backend())
        elif ('secp384r1' == key_curve):
            key = ec.generate_private_key(ec.SECP384R1(), default_backend())
        elif ('secp521r1' == key_curve):
            key = ec.generate_private_key(ec.SECP521R1(), default_backend())
        else:
            self._warn('Unsupported key curve: ', key_curve, '\n')
            return None
#        return OpenSSL.crypto.PKey.from_cryptography_key(key)  # currently not supported
        key_pem = key.private_bytes(encoding=Encoding.PEM, format=PrivateFormat.TraditionalOpenSSL, encryption_algorithm=NoEncryption())
        return OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_pem)

    def generate_private_key(self, key_type, options):
        if ('rsa' == key_type):
            return self.generate_rsa_key(*options)
        if ('ecdsa' == key_type):
            return self.generate_ecdsa_key(*options)
        self._warn('Unknown key type ', key_type.upper(), '\n')
        return None

    def key_cipher_data(self, private_key_name, force_prompt=False):
        if (private_key_name in self.key_passphrases):
            if (self.key_passphrases[private_key_name] or (not force_prompt)):
                return self.key_passphrases[private_key_name]
        private_keys = self._config('private_keys')
        if (private_key_name in private_keys):
            passphrase = self._option(private_keys[private_key_name], 'key_passphrase')
            if ((passphrase is True) or (force_prompt and not passphrase)):
                if (self.args.passphrase):
                    passphrase = self.args.passphrase[0]
                else:
                    passphrase = os.getenv('{script}_PASSPHRASE'.format(script=self.script_name.upper()))
                    if (not passphrase):
                        if (sys.stdin.isatty()):
                            passphrase = getpass.getpass('Enter private key password for {name}: '.format(name=private_key_name))
                        else:
                            passphrase = sys.stdin.readline().strip()
            key_cipher_data = KeyCipherData(self._option(private_keys[private_key_name], 'key_cipher'), passphrase, force_prompt) if (passphrase) else None
            self.key_passphrases[private_key_name] = key_cipher_data
            return key_cipher_data
        return None

    def load_private_key(self, file_type, file_name, key_type, key_cipher_data=None):
        key_file_path = self._file_path(file_type, file_name, key_type)
        if (os.path.isfile(key_file_path)):
            try:
                with open(key_file_path, 'r') as private_key_file:
                    key_pem = private_key_file.read()
                    if ('-----BEGIN ENCRYPTED PRIVATE KEY-----' in key_pem):
                        if (not key_cipher_data):
                            key_cipher_data = self.key_cipher_data(file_name, force_prompt=True)
                        private_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_pem.encode('ascii'),
                                                                     key_cipher_data.passphrase.encode('utf-8'))
                    else:
                        private_key = OpenSSL.crypto.load_privatekey(OpenSSL.crypto.FILETYPE_PEM, key_pem.encode('ascii'))
                    return KeyData(private_key, os.stat(key_file_path).st_mtime)
            except Exception:
                raise PrivateKeyError(key_file_path)
        return KeyData(None, None)

    def save_private_key(self, file_type, file_name, key_type, private_key, key_cipher_data,
                         timestamp=None, certificate=None, chain=[], dhparam_pem=None, ecparam_pem=None):
        with FileTransaction(file_type, self._file_path(file_type, file_name, key_type), chmod=0o640, timestamp=timestamp) as transaction:
            if (private_key):
                if (key_cipher_data and not key_cipher_data.forced):
                    try:
                        key_pem = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, private_key, key_cipher_data.cipher,
                                                                 key_cipher_data.passphrase.encode('utf-8'))
                    except Exception:
                        raise PrivateKeyError(file_name)
                else:
                    key_pem = OpenSSL.crypto.dump_privatekey(OpenSSL.crypto.FILETYPE_PEM, private_key)
                transaction.write(key_pem.decode('ascii'))
                if (certificate):
                    transaction.write('\n')
                    self._save_certificate(transaction, certificate, chain=chain, dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem)
        return transaction

    def archive_private_key(self, file_type, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file(file_type, self._file_path(file_type, file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _time_to_rollover(self, backup_key_timestamp, expiration_days):
        if (backup_key_timestamp and expiration_days):
            backup_key_modified_time = datetime.datetime.utcfromtimestamp(backup_key_timestamp)
            return (expiration_days < (datetime.datetime.utcnow() - backup_key_modified_time).days)
        return False

    def _safe_to_rollover(self, backup_key_timestamp, hpkp_days):
        if (backup_key_timestamp and hpkp_days):
            backup_key_modified_time = datetime.datetime.utcfromtimestamp(backup_key_timestamp)
            return (hpkp_days < (datetime.datetime.utcnow() - backup_key_modified_time).days)
        return True

    def _public_key_bytes(self, private_key):
        if (private_key):
            return private_key.to_cryptography_key().public_key().public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
        return None

    def _certificate_public_key_bytes(self, certificate):
        if (certificate):
            return certificate.get_pubkey().to_cryptography_key().public_bytes(Encoding.DER, PublicFormat.SubjectPublicKeyInfo)
        return None

    def _public_key_digest(self, private_key, digest='sha256'):
        if ('sha256' == digest):
            return hashlib.sha256(self._public_key_bytes(private_key)).digest()
        return hashlib.sha512(self._public_key_bytes(private_key)).digest()

    def _certificate_bytes(self, certificate):
        if (certificate):
            return OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_ASN1, certificate.wrapped)
        return None

    def _generate_hpkp_headers(self, file_name, private_keys, hpkp_days, pin_subdomains, report_uri):
        pins = '; '.join([r'pin-sha256=\"{digest}\"'.format(digest=base64.b64encode(self._public_key_digest(private_key)).decode('ascii'))
                         for private_key in private_keys])
        duration = str(hpkp_days * 86400)
        sub_domains = ' includeSubdomains;' if (pin_subdomains) else ''
        report = r' report-uri=\"{report_uri}\";'.format(report_uri=report_uri) if (report_uri) else ''
        header = '{pins}; max-age={duration};{sub_domains}{report}'.format(pins=pins, duration=duration, sub_domains=sub_domains, report=report)

        hpkp_headers = self._config('hpkp_headers')
        server_headers = {}
        for server, header_format in hpkp_headers.items():
            if (header_format):
                server_headers[server] = header_format.format(header=header, server=server, name=file_name)
        return server_headers

    def hpkp_headers_present(self, file_name, private_keys, hpkp_days, pin_subdomains, report_uri):
        server_headers = self._generate_hpkp_headers(file_name, private_keys, hpkp_days, pin_subdomains, report_uri)
        for server, header in server_headers.items():
            header_file_path = self._file_path('hpkp', file_name, server=server)
            if (os.path.isfile(header_file_path)):
                with open(header_file_path, 'r') as header_file:
                    if (header != header_file.read()):
                        return False
            else:
                return False
        return True

    def save_hpkp_headers(self, file_name, private_keys, hpkp_days, pin_subdomains, report_uri):
        server_headers = self._generate_hpkp_headers(file_name, private_keys, hpkp_days, pin_subdomains, report_uri)
        transactions = []
        for server, header in server_headers.items():
            with FileTransaction('hpkp', self._file_path('hpkp', file_name, server=server), chmod=0o644) as transaction:
                transaction.write(header)
                transactions.append(transaction)
        return transactions

    def archive_hpkp_headers(self, file_name, archive_name='', archive_date=None):
        hpkp_headers = self._config('hpkp_headers')
        for server in hpkp_headers:
            self._archive_file('hpkp', self._file_path('hpkp', file_name, server=server), archive_name=archive_name, archive_date=archive_date)

    def get_alt_names(self, certificate):
        for index in range(certificate.get_extension_count()):
            extension = certificate.get_extension(index)
            if (b'subjectAltName' == extension.get_short_name()):
                return [alt_name.split(':')[1] for alt_name in str(extension).split(', ')]
        return []

    def _private_key_matches_certificate(self, private_key, certificate):
        return self._public_key_bytes(private_key) == self._certificate_public_key_bytes(certificate)

    def _certificate_digest(self, certificate, digest='sha256'):
        return certificate.wrapped.digest(digest).decode('ascii').replace(':', '').lower()

    def load_certificate(self, file_type, file_name, key_type):
        try:
            with open(self._file_path(file_type, file_name, key_type), 'r') as certificate_file:
                return jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate_file.read().encode('ascii')))
        except Exception:
            return None

    def load_root_certificates(self):
        root_certificates = collections.OrderedDict()
        for key_type in self._key_types:
            root_certificates[key_type] = self.load_certificate('certificate', os.path.join(os.path.dirname(self.config_file_path), 'root_cert'), key_type)
        return root_certificates

    def save_certificate(self, file_type, file_name, key_type, certificate, chain=[], root_certificate=None, dhparam_pem=None, ecparam_pem=None):
        with FileTransaction(file_type, self._file_path(file_type, file_name, key_type), chmod=0o644) as transaction:
            self._save_certificate(transaction.file, certificate, chain=chain, root_certificate=root_certificate,
                                   dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem)
        return transaction

    def archive_certificate(self, file_type, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file(file_type, self._file_path(file_type, file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _save_certificate(self, certificate_file, certificate, chain=None, root_certificate=None, dhparam_pem=None, ecparam_pem=None):
        certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate.wrapped).decode('ascii')
        certificate_not_before = self._datetime_from_asn1_generaltime(certificate.get_notBefore())
        certificate_file.write(certificate.get_subject().commonName + ' issued at ' + certificate_not_before.strftime('%Y-%m-%d %H:%M:%S UTC') + '\n')
        certificate_file.write(certificate_pem)
        if (chain):
            self._save_chain(certificate_file, chain, '\n')
        if (root_certificate):
            root_certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, root_certificate.wrapped).decode('ascii')
            certificate_file.write('\n' + root_certificate.get_subject().commonName + '\n')
            certificate_file.write(root_certificate_pem)
        if (dhparam_pem):
            certificate_file.write('\n' + dhparam_pem)
        if (ecparam_pem):
            certificate_file.write('\n' + ecparam_pem)

    def load_chain(self, file_name, key_type):
        chain = []
        try:
            pem_data = None
            if (self._directory('chain')):
                chain_file_path = self._file_path('chain', file_name, key_type)
                if (os.path.isfile(chain_file_path)):
                    with open(chain_file_path) as chain_file:
                        pem_data = chain_file.read()
                        index = 0
            if (not pem_data):
                with open(self._file_path('certificate', file_name, key_type)) as certificate_file:
                    pem_data = certificate_file.read()
                    index = 1
            certificate_pems = re.findall('-----BEGIN CERTIFICATE-----.*?-----END CERTIFICATE-----', pem_data, re.DOTALL)[index:]
            for certificate_pem in certificate_pems:
                chain.append(jose.ComparableX509(OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, certificate_pem.encode('ascii'))))
        except Exception:
            pass
        return chain

    def save_chain(self, file_name, key_type, chain):
        with FileTransaction('chain', self._file_path('chain', file_name, key_type), chmod=0o644) as transaction:
            self._save_chain(transaction.file, chain)
        return transaction

    def archive_chain(self, file_name, key_type, archive_name='', archive_date=None):
        self._archive_file('chain', self._file_path('chain', file_name, key_type), archive_name=archive_name, archive_date=archive_date)

    def _save_chain(self, chain_file, chain, lead_in=''):
        for chain_certificate in chain:
            chain_certificate_pem = OpenSSL.crypto.dump_certificate(OpenSSL.crypto.FILETYPE_PEM, chain_certificate.wrapped).decode('ascii')
            chain_file.write(lead_in + chain_certificate.get_subject().commonName + '\n')
            chain_file.write(chain_certificate_pem)
            lead_in = '\n'

    def generate_dhparam(self, dhparam_size):
        if (dhparam_size):
            try:
                return subprocess.check_output(['openssl', 'dhparam', str(dhparam_size)], stderr=subprocess.DEVNULL).decode('ascii')
            except Exception:
                pass
        return None

    def generate_ecparam(self, ecparam_curve):
        if (ecparam_curve):
            try:
                return subprocess.check_output(['openssl', 'ecparam', '-name', ecparam_curve], stderr=subprocess.DEVNULL).decode('ascii')
            except Exception:
                pass
        return None

    def params_present(self, file_name, dhparam_pem, ecparam_pem):
        param_file_path = self._file_path('param', file_name)
        if (os.path.isfile(param_file_path)):
            with open(param_file_path, 'r') as param_file:
                params = param_file.read()
                return (((not dhparam_pem) or (dhparam_pem in params)) and ((not ecparam_pem) or (ecparam_pem in params)))
        return False

    def load_params(self, file_name):
        try:
            pem_data = None
            if (self._directory('param')):
                param_file_path = self._file_path('param', file_name)
                if (os.path.isfile(param_file_path)):
                    with open(param_file_path) as param_file:
                        pem_data = param_file.read()
            if (not pem_data):
                for key_type in self._key_types:
                    certificate_file_path = self._file_path('certificate', file_name, key_type)
                    if (os.path.isfile(certificate_file_path)):
                        with open(certificate_file_path) as certificate_file:
                            pem_data = certificate_file.read()
                        break
            if (pem_data):
                match = re.match(r'.*(-----BEGIN DH PARAMETERS-----.*-----END DH PARAMETERS-----)', pem_data, re.DOTALL)
                dhparam_pem = (match.group(1) + '\n') if (match) else None
                match = re.match(r'.*(-----BEGIN EC PARAMETERS-----.*-----END EC PARAMETERS-----)', pem_data, re.DOTALL)
                ecparam_pem = (match.group(1) + '\n') if (match) else None
                return (dhparam_pem, ecparam_pem)
        except Exception:
            pass
        return (None, None)

    def save_params(self, file_name, dhparam_pem, ecparam_pem):
        with FileTransaction('param', self._file_path('param', file_name), chmod=0o640) as transaction:
            if (dhparam_pem and ecparam_pem):
                transaction.write(dhparam_pem + '\n' + ecparam_pem)
            else:
                transaction.write(dhparam_pem or ecparam_pem)
        return transaction

    def archive_params(self, file_name, archive_name='', archive_date=None):
        self._archive_file('param', self._file_path('param', file_name), archive_name=archive_name, archive_date=archive_date)

    def _sct_datetime(self, sct_timestamp):
        return datetime.datetime.utcfromtimestamp(sct_timestamp / 1000)

    def fetch_sct(self, ct_log_name, certificate, chain):
        ct_log = self._config('ct_logs', ct_log_name)
        if (ct_log and ('url' in ct_log)):
            certificates = ([base64.b64encode(self._certificate_bytes(certificate)).decode('ascii')]
                            + [base64.b64encode(self._certificate_bytes(chain_certificate)).decode('ascii') for chain_certificate in chain])
            request_data = json.dumps({'chain': certificates}).encode('ascii')
            request = urllib.request.Request(url=ct_log['url'] + '/ct/v1/add-chain', data=request_data)
            request.add_header('Content-Type', 'application/json')
            try:
                with urllib.request.urlopen(request) as response:
                    sct = json.loads(response.read().decode('utf-8'))
                    return SCTData(sct.get('sct_version'), sct.get('id'), sct.get('timestamp'), sct.get('extensions'), sct.get('signature'))
            except urllib.error.HTTPError as error:
                if ((400 <= error.code) and (error.code < 500)):
                    self._warn('Unable to retrieve SCT from log ', ct_log_name, ' HTTP error: ', error.code, ' ', error.reason, '\n', error.read(), '\n')
                else:
                    self._warn('Unable to retrieve SCT from log ', ct_log_name, ' HTTP error: ', error.code, ' ', error.reason, '\n')
            except urllib.error.URLError as error:
                self._warn('Unable to retrieve SCT from log ', ct_log_name, ' ', error.reason, '\n')
        else:
            self._warn('Unknown CT log: ', ct_log_name, '\n')
        return None

    def load_sct(self, file_name, key_type, ct_log_name):
        try:
            ct_log = self._config('ct_logs', ct_log_name)
            if (ct_log and ('id' in ct_log)):
                sct_file_path = self._file_path('sct', file_name, key_type, ct_log_name=ct_log_name)
                with open(sct_file_path, 'rb') as sct_file:
                    sct = sct_file.read()
                    version, id, timestamp, extensions_len = struct.unpack('>b32sQH', sct[:43])
                    id = base64.b64encode(id).decode('ascii')
                    extensions = base64.b64encode(sct[43:(43 + extensions_len)]).decode('ascii') if (extensions_len) else ''
                    signature = base64.b64encode(sct[43 + extensions_len:]).decode('ascii')

                    if (ct_log['id'] == id):
                        return SCTData(version, id, timestamp, extensions, signature)
                    else:
                        self._note('SCT ', sct_file_path, ' does not match log id for ', ct_log_name, '\n')
        except Exception:
            pass
        return None

    def save_sct(self, file_name, key_type, ct_log_name, sct_data):
        ct_log = self._config('ct_logs', ct_log_name)
        if (ct_log):
            with FileTransaction('sct', self._file_path('sct', file_name, key_type, ct_log_name=ct_log_name), chmod=0o640, mode='wb') as transaction:
                extensions = base64.b64decode(sct_data.extensions)
                sct = struct.pack('>b32sQH', sct_data.version, base64.b64decode(sct_data.id), sct_data.timestamp, len(extensions))
                sct += extensions + base64.b64decode(sct_data.signature)
                transaction.write(sct)
            return transaction
        return None

    def archive_sct(self, file_name, key_type, ct_log_name, archive_name='', archive_date=None):
        self._archive_file('sct', self._file_path('sct', file_name, key_type, ct_log_name=ct_log_name), archive_name=archive_name, archive_date=archive_date)

    def generate_csr(self, private_key, common_name, alt_names=[], must_staple=False):
        req = OpenSSL.crypto.X509Req()
        req.get_subject().CN = common_name
        extensions = [
            OpenSSL.crypto.X509Extension(
                b'subjectAltName',
                critical=False,
                value=', '.join('DNS:%s' % domain_name for domain_name in alt_names).encode('ascii')
            )
        ]
        if (must_staple):
            extensions.append(OpenSSL.crypto.X509Extension(
                b'1.3.6.1.5.5.7.1.24',
                critical=False,
                value=b'DER:30:03:02:01:05'))
        req.add_extensions(extensions)
        req.set_version(2)
        req.set_pubkey(private_key)
        req.sign(private_key, 'sha256')
        return req

    def _validate_config(self):
        for section_name, default_section in self._config_defaults.items():
            if (section_name not in self.config):
                self.config[section_name] = default_section
            else:
                for key, value in default_section.items():
                    if (key not in self.config[section_name]):
                        self.config[section_name][key] = value

        private_keys = self.config.get('private_keys', collections.OrderedDict())
        if ('certificates' in self.config):     # convert bare certificate definitions to private key definitions
            certificates = self.config['certificates']
            for certificate_name in certificates:
                if (certificate_name not in private_keys):
                    private_keys[certificate_name] = collections.OrderedDict()
                if ('certificates' not in private_keys[certificate_name]):
                    private_keys[certificate_name]['certificates'] = collections.OrderedDict()
                if (certificate_name not in private_keys[certificate_name]['certificates']):
                    for config_key in ('key_types', 'key_size', 'key_curve', 'key_cipher', 'key_passphrase',
                                       'expiration_days', 'auto_rollover',
                                       'hpkp_days', 'pin_subdomains', 'hpkp_report_uri'):
                        if ((config_key in certificates[certificate_name]) and (config_key not in private_keys[certificate_name])):
                            private_keys[certificate_name][config_key] = certificates[certificate_name][config_key]
                            del certificates[certificate_name][config_key]
                    private_keys[certificate_name]['certificates'][certificate_name] = certificates[certificate_name]
                else:
                    self._error('Certificate ', certificate_name, ' already configured with private key\n')
            del self.config['certificates']

        for private_key_name in private_keys:
            key_certificates = private_keys[private_key_name].get('certificates', {})
            if (not key_certificates):
                self._error('No certificates defined for private key ', private_key_name, '\n')
            certificate_key_types = set()
            for certificate_name in key_certificates:
                for zone_name in key_certificates[certificate_name].get('alt_names', {}):
                    common_name = key_certificates[certificate_name].get('common_name', certificate_name)
                    if (common_name in self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name)):
                        break
                else:
                    self._error('Certificate common name "', common_name, '" not listed in alt_names\n')
                certificate_key_types |= set(self._get_list(key_certificates[certificate_name], 'key_types', self._key_types))
            key_options = self._get_key_options(private_keys[private_key_name])
            private_keys[private_key_name]['key_types'] = [key_type for key_type in key_options if (key_type in certificate_key_types)]
        self.config['private_keys'] = private_keys

    def connect_client(self):
        resource_dir = os.path.join(self.script_dir, self._directory('resource'))
        self._makedir(resource_dir, 0o600)
        client_key_path = os.path.join(resource_dir, 'client_key.json')
        if (os.path.isfile(client_key_path)):
            with open(client_key_path) as client_key_file:
                self.client_key = jose.JWKRSA.fields_from_json(json.load(client_key_file))
                self._note('Loaded clent key ', client_key_path, '\n')
        else:
            self._status('Client key not present, generating\n')
            self.client_key = jose.JWKRSA(key=rsa.generate_private_key(public_exponent=65537, key_size=4096, backend=default_backend()))
            try:
                with self._open_file(client_key_path, 'w', 0o600) as client_key_file:
                    json.dump(self.client_key.fields_to_partial_json(), client_key_file)
                    self._note('Saved client key ', client_key_path, '\n')
            except Exception:
                self._error('Unable to save client key to ', client_key_path, '\n')

        try:
            user_agent = '{script}/{version} acme-python/{acme_version}'.format(script=self.script_name, version=self.script_version,
                                                                                acme_version=pkg_resources.get_distribution('acme').version)
            network = client.ClientNetwork(self.client_key, user_agent=user_agent)
            self.acme_client = client.Client(self._setting('acme_directory_url'), self.client_key, net=network)
        except Exception as error:
            self._error("Can't connect to ACME service.\n", error, '\n')

        registration_path = os.path.join(resource_dir, 'registration.json')
        if (os.path.isfile(registration_path)):
            with open(registration_path) as registration_file:
                self.registration = messages.RegistrationResource.json_loads(registration_file.read())
                self._note('Loaded registration ', registration_path, '\n')

            self.registration = self.acme_client.query_registration(self.registration)
        else:
            self._note('Registering client\n')
            self.registration = self.acme_client.register(messages.NewRegistration.from_data(email=self._account('email')))
            self._note('Auto-accepting TOS: ', self.registration.terms_of_service, '\n')
            self.acme_client.agree_to_tos(self.registration)
            self.registration = self.acme_client.query_registration(self.registration)   # get agreement info
        with FileTransaction('registration', registration_path, chmod=0o600) as transaction:
            transaction.write(self.registration.json_dumps())
            self._note('Saved registration ', registration_path, '\n')
        try:
            self._commit_file_transactions([transaction], archive_name=None)
        except Exception:
            self._error('Unable to save registration to ', registration_path, '\n')

    def process_authorizations(self, private_key_names=[]):
        private_keys = self._config('private_keys')
        authorizations = self._config('authorizations')

        domain_challenges = {}
        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue
            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                for zone_name in key_certificates[certificate_name]['alt_names']:
                    if (zone_name not in domain_challenges):
                        domain_challenges[zone_name] = []
                    for domain_name in self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name):
                        if (domain_name not in domain_challenges[zone_name]):
                            domain_challenges[zone_name].append(domain_name)

        if (not self._setting('slave_mode')):
            for zone_name in authorizations:
                if (zone_name not in domain_challenges):
                    domain_challenges[zone_name] = []
                for domain_name in self._get_domain_names(authorizations, zone_name):
                    if (domain_name not in domain_challenges[zone_name]):
                        domain_challenges[zone_name].append(domain_name)

        # get authorizations
        authorization_resources = {}
        for zone_name in domain_challenges:
            for domain_name in domain_challenges[zone_name]:
                self._debug('Request authorization for ', domain_name, '\n')
                authorization_resource = self.acme_client.request_domain_challenges(domain_name, new_authzr_uri=self.registration.new_authzr_uri)
                if (messages.STATUS_VALID == authorization_resource.body.status):
                    self.authorizations[domain_name] = authorization_resource
                    self._debug(domain_name, ' already authorized\n')
                elif (messages.STATUS_PENDING == authorization_resource.body.status):
                    if (not self._setting('slave_mode')):
                        authorization_resources[domain_name] = authorization_resource
                    else:
                        self._debug(domain_name, ' not authorized\n')
                else:
                    self._error('Unexpected status "', authorization_resource.body.status, '" for authorization of ', domain_name, '\n')

        # set challenge responses
        challenge_types = {}
        challenge_dns_responses = {}
        challenge_http_responses = {}
        for zone_name in domain_challenges:
            zone_responses = {}
            for domain_name in domain_challenges[zone_name]:
                if (domain_name in authorization_resources):
                    http_challenge_directory = self._http_challenge_directory(domain_name)
                    if (http_challenge_directory):
                        challenge_types[domain_name] = 'http-01'
                        challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
                        challenge_file_path = os.path.join(http_challenge_directory, challenge.chall.encode('token'))
                        self._debug('Setting http acme-challenge for ', domain_name, ' in file ', challenge_file_path, '\n')
                        try:
                            with self._open_file(challenge_file_path, 'w', 0o644) as challenge_file:
                                challenge_file.write(challenge.validation(self.client_key))
                            challenge_http_responses[domain_name] = challenge_file_path
                        except Exception as error:
                            self._warn('Unable to create acme-challenge file ', challenge_file_path, '\n', error, '\n')
                    else:
                        challenge_types[domain_name] = 'dns-01'
                        challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
                        zone_responses[domain_name] = challenge.validation(self.client_key)
                        self._debug('Setting DNS for _acme-challenge.', domain_name, ' = "', zone_responses[domain_name], '"\n')
            if (zone_responses):
                zone_key = self._zone_key(zone_name)
                if (zone_key):
                    if (self._set_dns_challenges(zone_name, zone_key, zone_responses)):
                        challenge_dns_responses[zone_name] = zone_responses
                else:
                    try:
                        with self._open_file(self._file_path('challenge', zone_name), 'w', 0o644) as challenge_file:
                            json.dump(zone_responses, challenge_file)
                        challenge_dns_responses[zone_name] = zone_responses
                    except Exception as error:
                        self._warn('Unable to create acme-challenge file for zone ', zone_name, '\n', error, '\n')
                    if (zone_name in challenge_dns_responses):
                        self._reload_zone(zone_name)

        # wait for DNS propagation
        waiting = []
        for zone_name in challenge_dns_responses:
            name_servers = self._get_name_servers(zone_name)
            self._note('Got name servers ', name_servers, ' for ', zone_name, '\n')
            for name_server in name_servers:
                waiting += [DNSTuple(datetime.datetime.now(), name_server, domain_name, challenge_dns_responses[zone_name][domain_name], 0)
                            for domain_name in challenge_dns_responses[zone_name]]
        while waiting:
            when, name_server, domain_name, response, attempt_count = heapq.heappop(waiting)
            now = datetime.datetime.now()
            if (now < when):
                seconds = (when - now).seconds
                if (0 < seconds):
                    time.sleep(seconds)
            dns_challenges = self._lookup_dns_challenge(name_server, domain_name)
            if (response in dns_challenges):
                self._debug('Challenge present for ', domain_name, ' at ', name_server, '\n')
            else:
                self._note('Challenge missing for ', domain_name, ' at ', name_server, '\n')
                if (attempt_count < self._setting('max_dns_lookup_attempts')):
                    heapq.heappush(waiting, DNSTuple(datetime.datetime.now() + datetime.timedelta(seconds=self._setting('dns_lookup_delay')),
                                                     name_server, domain_name, response, attempt_count + 1))
                else:
                    self._warn('Maximum attempts reached waiting for DNS challenge ', domain_name, ' at ', name_server, '\n')
        if (challenge_dns_responses):
            time.sleep(2)

        # answer challenges
        for domain_name in authorization_resources:
            self._debug('Answering challenge for ', domain_name, '\n')
            challenge = self._get_challenge(authorization_resources[domain_name], challenge_types[domain_name])
            self.acme_client.answer_challenge(challenge, challenge.response(self.client_key))

        # poll for authorizations
        waiting = [AuthorizationTuple(datetime.datetime.now(), authorization_resource) for authorization_resource in authorization_resources.values()]
        attempts = collections.defaultdict(int)
        exhausted = []
        failed = []
        while waiting:
            when, authorization_resource = heapq.heappop(waiting)
            now = datetime.datetime.now()
            if (now < when):
                seconds = (when - now).seconds
                if (0 < seconds):
                    time.sleep(seconds)
            self._debug('Polling for ', authorization_resource.body.identifier.value, '\n')
            authorization_resource, response = self.acme_client.poll(authorization_resource)
            if (200 != response.status_code):
                self._warn(response, ' while waiting for domain challenge\n')
                heapq.heappush(waiting, AuthorizationTuple(
                    self.acme_client.retry_after(response, default=self._setting('authorization_delay')),
                    authorization_resource))
                continue

            attempts[authorization_resource] += 1
            if (messages.STATUS_VALID == authorization_resource.body.status):
                self.authorizations[authorization_resource.body.identifier.value] = authorization_resource
                self._debug('Authorization received\n')
                continue
            elif (messages.STATUS_INVALID == authorization_resource.body.status):
                self._debug('Invalid authorization: ', self._get_challenge(authorization_resource, challenge_types[domain_name]).error.detail, '\n')
                failed.append(authorization_resource)
            elif (messages.STATUS_PENDING == authorization_resource.body.status):
                if (self._setting('max_authorization_attempts') < attempts[authorization_resource]):
                    exhausted.append(authorization_resource)
                    self._note('Giving up\n')
                else:
                    self._note('Retrying\n')
                    heapq.heappush(waiting, AuthorizationTuple(
                        self.acme_client.retry_after(response, default=self._setting('authorization_delay')),
                        authorization_resource))
            else:
                self._error('Unexpected status "', authorization_resource.body.status, '"\n')

        # clear challenge responses
        for zone_name in challenge_dns_responses:
            self._debug('Removing DNS _acme-challenges for ', zone_name, '\n')
            zone_key = self._zone_key(zone_name)
            if (zone_key):
                self._remove_dns_challenges(zone_name, zone_key, challenge_dns_responses[zone_name])
            else:
                os.remove(self._file_path('challenge', zone_name))
                self._reload_zone(zone_name)
        for domain_name in challenge_http_responses:
            self._debug('Removing http acme-challenge for ', domain_name, '\n')
            os.remove(challenge_http_responses[domain_name])

        for authorization_resource in failed:
            self._status('Authorization failed for ', authorization_resource.body.identifier.value, '\n')
        for authorization_resource in exhausted:
            self._status('Authorization timed out for ', authorization_resource.body.identifier.value, '\n')

    def _get_key_options(self, private_key_config):
        key_size = self._option(private_key_config, 'key_size')
        key_curve = self._option(private_key_config, 'key_curve')
        key_types = self._get_list(private_key_config, 'key_types', self._key_types)
        key_options = collections.OrderedDict()
        if (key_size and ('rsa' in key_types)):
            key_options['rsa'] = (key_size, )
        if (key_curve and ('ecdsa' in key_types)):
            key_options['ecdsa'] = (key_curve, )
        return key_options

    def process_certificates(self, private_key_names=[]):
        private_keys = self._config('private_keys')
        updated_key_zones = set()
        processed_keys = []

        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue

            self._debug('Processing private key ', private_key_name, '\n')

            key_options = self._get_key_options(private_keys[private_key_name])
            if (not key_options):
                self._warn('No configured private key types for ', private_key_name, '\n')
                continue

            hpkp_days = self._option(private_keys[private_key_name], 'hpkp_days')
            expiration_days = self._option(private_keys[private_key_name], 'expiration_days')

            rolled_private_key = False
            generated_private_key = False
            changed_private_key = False

            key_cipher_data = self.key_cipher_data(private_key_name)
            backup_keys = {}
            youngest_key_timestamp = sys.maxsize
            oldest_key_timestamp = 0
            try:
                for key_type in key_options:
                    backup_key_data = self.load_private_key('backup_key', private_key_name, key_type, key_cipher_data)
                    if (backup_key_data.timestamp):
                        youngest_key_timestamp = min(youngest_key_timestamp, backup_key_data.timestamp)
                        oldest_key_timestamp = max(oldest_key_timestamp, backup_key_data.timestamp)
                    backup_keys[key_type] = backup_key_data
            except PrivateKeyError as error:
                self._warn('Unable to load backup private key ', error, '\n')
                continue

            rollover = False
            if (self.args.rollover
                or (self._option(private_keys[private_key_name], 'auto_rollover')
                    and self._time_to_rollover(oldest_key_timestamp, expiration_days))):
                if (self.args.force_rollover or self._safe_to_rollover(youngest_key_timestamp, hpkp_days)):
                    rollover = True
                else:
                    self._warn('Backup private key for ', private_key_name, ' is younger than HPKP duration, rollover skipped\n',
                               'Use "--force" to force key rollover, note that this can brick a web site if HPKP is deployed\n')

            if (rollover):
                keys = {key_type: KeyData(None, None) for key_type in key_options}
            else:
                try:
                    keys = {key_type: self.load_private_key('private_key', private_key_name, key_type, key_cipher_data) for key_type in key_options}
                except PrivateKeyError as error:
                    self._warn('Unable to load private key ', error, '\n')
                    continue

            for key_type in key_options:
                if (backup_keys[key_type].key and not keys[key_type].key):
                    keys[key_type] = backup_keys[key_type]
                    backup_keys[key_type] = KeyData(None, None)
                    rolled_private_key = True
            if (rolled_private_key):
                self._status('Private key rolled over for ', private_key_name, '\n')

            if (not rolled_private_key
                    and self._time_to_rollover(oldest_key_timestamp, expiration_days)
                    and self._safe_to_rollover(youngest_key_timestamp, hpkp_days)):
                self._status('Backup key for ', private_key_name, ' has expired. Use "--rollover" to replace.\n')

            for key_type, options in key_options.items():
                if (not keys[key_type].key):
                    self._status('Generating primary ', key_type.upper(), ' key for ', private_key_name, '\n')
                    private_key = self.generate_private_key(key_type, options)
                    keys[key_type] = KeyData(private_key, None)
                    if (private_key):
                        generated_private_key = True

            for key_type, key_data in keys.items():
                if (not key_data.key):
                    del key_options[key_type]

            issued_certificates = []
            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                self._debug('Processing certificate ', certificate_name, '\n')

                alt_names = []
                for zone_name in key_certificates[certificate_name]['alt_names']:
                    alt_names += self._get_domain_names(key_certificates[certificate_name]['alt_names'], zone_name)

                missing_authorizations = [alt_name for alt_name in alt_names if (alt_name not in self.authorizations)]
                if (missing_authorizations):
                    self._status('Unable to issue certificate ', certificate_name, ' due to missing authorization(s) for: ',
                                 ', '.join(missing_authorizations), '\n')
                    if (rolled_private_key):
                        issued_certificates = []    # do not partially install new certificates if private key changed
                        break
                    continue

                common_name = key_certificates[certificate_name].get('common_name', certificate_name)
                certificate_key_types = self._get_list(key_certificates[certificate_name], 'key_types', key_options.keys())
                for key_type in certificate_key_types:
                    if ((key_type not in keys) or (not keys[key_type].key)):
                        self._warn('No ', key_type.upper(), ' private key available for certificate ', certificate_name, '\n')
                        continue

                    if ((not rolled_private_key) and (not self.args.renew)):
                        existing_certificate = self.load_certificate('certificate', certificate_name, key_type)
                        if (existing_certificate):
                            certificate_common_name = existing_certificate.get_subject().commonName
                            if (common_name != certificate_common_name):
                                self._status('Common name changed for ', key_type.upper(), ' certificate ', certificate_name, ' from ', certificate_common_name,
                                             ' to ', common_name, '\n')
                            else:
                                certificate_alt_names = self.get_alt_names(existing_certificate)
                                new_alt_names = set(alt_names)
                                existing_alt_names = set(certificate_alt_names)
                                if (new_alt_names != existing_alt_names):
                                    added_alt_names = new_alt_names - existing_alt_names
                                    removed_alt_names = existing_alt_names - new_alt_names
                                    added = ', '.join([alt_name for alt_name in alt_names if (alt_name in added_alt_names)])
                                    removed = ', '.join([alt_name for alt_name in certificate_alt_names if (alt_name in removed_alt_names)])
                                    self._status('Alt names changed for ', key_type.upper(), ' certificate ', certificate_name,
                                                 (', adding ' + added) if added else '',
                                                 (', removing ' + removed) if removed else '',
                                                 '\n')
                                else:
                                    if (not self._private_key_matches_certificate(keys[key_type].key, existing_certificate)):
                                        self._status(key_type.upper(), ' certificate ', certificate_name, ' public key does not match private key\n')
                                        changed_private_key = True
                                    else:
                                        valid_duration = self._datetime_from_asn1_generaltime(existing_certificate.get_notAfter()) - datetime.datetime.utcnow()
                                        if (valid_duration.days < 0):
                                            self._status(key_type.upper(), ' certificate ', certificate_name, ' has expired\n')
                                        elif (valid_duration.days < self._setting('renewal_days')):
                                            self._status(key_type.upper(), ' certificate ', certificate_name, ' will expire in ',
                                                         (str(valid_duration.days) + ' days') if (valid_duration.days) else 'less than a day',
                                                         '\n')
                                        else:
                                            self._debug(key_type.upper(), ' certificate valid beyond renewal window\n')
                                            continue

                    csr = self.generate_csr(keys[key_type].key, common_name, alt_names,
                                            self._option(key_certificates[certificate_name], 'ocsp_must_staple'))
                    self._status('Requesting ', key_type.upper(), ' certificate for ', common_name,
                                 (' with alt names: ' + ', '.join(alt_names)) if (alt_names) else '', '\n')
                    try:
                        certificate_resource = self.acme_client.request_issuance(jose.ComparableX509(csr),
                                                                                 [self.authorizations[domain_name] for domain_name in alt_names])
                    except Exception as error:
                        self._warn(key_type.upper(), ' certificate issuance failed\n', error, '\n')
                        if (rolled_private_key):
                            issued_certificates = []    # do not partially install new certificates if private key changed
                            break
                        continue

                    self._debug('New ', key_type.upper(), ' certificate issued\n')
                    chain = self.acme_client.fetch_chain(certificate_resource)
                    issued_certificates.append(CertificateData(certificate_name, key_type, certificate_resource.body, chain,
                                                               key_certificates[certificate_name]))

            processed_keys.append(PrivateKeyData(private_key_name, key_options, keys, backup_keys,
                                                 generated_private_key, rolled_private_key, changed_private_key, issued_certificates))

        # install keys and certificates
        root_certificates = self.load_root_certificates()

        for private_key_data in processed_keys:
            private_key_name = private_key_data.name

            generated_backup_key = False
            backup_keys = private_key_data.backup_keys
            for key_type, options in private_key_data.key_options.items():
                if (not backup_keys[key_type].key):
                    self._status('Generating backup ', key_type.upper(), ' key for ', private_key_name, '\n')
                    backup_keys[key_type] = KeyData(self.generate_private_key(key_type, options), None)
                    generated_backup_key = True

            transactions = []

            key_cipher_data = self.key_cipher_data(private_key_name)
            try:
                for key_type in private_key_data.key_options:
                    if (private_key_data.generated_key or private_key_data.rolled_key):
                        transactions.append(self.save_private_key('private_key', private_key_name, key_type,
                                                                  private_key_data.keys[key_type].key, key_cipher_data,
                                                                  timestamp=private_key_data.keys[key_type].timestamp))
                    if (generated_backup_key):
                        transactions.append(self.save_private_key('backup_key', private_key_name, key_type,
                                                                  backup_keys[key_type].key, key_cipher_data,
                                                                  timestamp=backup_keys[key_type].timestamp))
            except PrivateKeyError as error:
                self._warn('Unable to encrypt private key ', error, '\n')
                continue

            generated_hpkp_headers = False
            hpkp_days = self._option(private_keys[private_key_name], 'hpkp_days')
            if (0 < hpkp_days) and (self._directory('hpkp')):
                pin_subdomains = self._option(private_keys[private_key_name], 'pin_subdomains')
                hpkp_report_uri = self._option(private_keys[private_key_name], 'hpkp_report_uri')
                keys = ([private_key_data.keys[key_type].key for key_type in private_key_data.key_options if private_key_data.keys[key_type].key]
                        + [private_key_data.backup_keys[key_type].key for key_type in private_key_data.key_options
                           if private_key_data.backup_keys[key_type].key])
                if ((1 < len(keys))
                        and (private_key_data.generated_key or private_key_data.changed_key or generated_backup_key
                             or not self.hpkp_headers_present(private_key_name, keys, hpkp_days, pin_subdomains, hpkp_report_uri))):
                    self._status('Generating HPKP headers for ', private_key_name, '\n')
                    transactions += self.save_hpkp_headers(private_key_name, keys, hpkp_days, pin_subdomains, hpkp_report_uri)
                    generated_hpkp_headers = True

            processed_params = set()
            for certificate_data in private_key_data.issued_certificates:
                certificate_name = certificate_data.certificate_name
                if (certificate_name not in processed_params):
                    processed_params.add(certificate_name)

                    generated_params = False
                    dhparam_pem, ecparam_pem = self.load_params(certificate_name) if (not private_key_data.rolled_key) else (None, None)
                    if (not dhparam_pem):
                        dhparam_size = self._option(certificate_data.config, 'dhparam_size')
                        if (dhparam_size):
                            self._status('Generating Diffie-Hellman parameters for ', certificate_name, '\n')
                            dhparam_pem = self.generate_dhparam(dhparam_size)
                            generated_params = True
                    if (not ecparam_pem):
                        ecparam_curve = self._option(certificate_data.config, 'ecparam_curve')
                        if (ecparam_curve):
                            self._status('Generating elliptical curve parameters for ', certificate_name, '\n')
                            ecparam_pem = self.generate_ecparam(ecparam_curve)
                            generated_params = True

                    if ((dhparam_pem or ecparam_pem) and self._directory('param')
                            and (generated_params or not self.params_present(certificate_name, dhparam_pem, ecparam_pem))):
                        transactions.append(self.save_params(certificate_name, dhparam_pem, ecparam_pem))

                key_type = certificate_data.key_type
                transactions.append(self.save_certificate('certificate', certificate_name, key_type, certificate_data.certificate,
                                                          chain=certificate_data.chain,
                                                          dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))
                if (root_certificates[key_type] and self._directory('full_certificate')):
                    transactions.append(self.save_certificate('full_certificate', certificate_name, key_type, certificate_data.certificate,
                                                              chain=certificate_data.chain, root_certificate=root_certificates[key_type],
                                                              dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))
                if (certificate_data.chain and self._directory('chain')):
                    transactions.append(self.save_chain(certificate_name, key_type, certificate_data.chain))
                try:
                    if (self._directory('full_key')):
                        transactions.append(self.save_private_key('full_key', certificate_name, key_type, private_key_data.keys[key_type].key, key_cipher_data,
                                                                  certificate=certificate_data.certificate, chain=certificate_data.chain,
                                                                  dhparam_pem=dhparam_pem, ecparam_pem=ecparam_pem))
                except PrivateKeyError as error:
                    self._warn('Unable to encrypt private key ', error, '\n')
                    continue

            try:
                self._commit_file_transactions(transactions, archive_name=private_key_name)
                if (private_key_data.generated_key or private_key_data.rolled_key or generated_backup_key):
                    self._status('Private keys for ', private_key_name, ' installed\n')
                for certificate_data in private_key_data.issued_certificates:
                    certificate_name = certificate_data.certificate_name
                    self._status(certificate_data.key_type.upper(), ' certificate ', certificate_name, ' installed\n')
                    self.update_services(self._get_list(certificate_data.config, 'services'))
                    if (not self._setting('slave_mode')):
                        for zone_name in certificate_data.config['alt_names']:
                            if (not self._zone_key(zone_name)):
                                updated_key_zones.add(zone_name)
                if (generated_backup_key or generated_hpkp_headers):    # reload services for all certificates
                    key_certificates = private_keys[private_key_name].get('certificates', {})
                    for certificate_name in key_certificates:
                        self.update_services(self._get_list(key_certificates[certificate_name], 'services'))

            except Exception as error:
                self._warn('Unable to install keys and certificates for ', private_key_name, '\n', error, '\n')

        for zone_name in updated_key_zones:
            self._reload_zone(zone_name)

    def revoke_certificates(self, private_key_names):
        private_keys = self._config('private_keys')
        updated_key_zones = set()
        updated_tlsa_zones = collections.OrderedDict()

        for private_key_name in private_key_names:
            if (private_key_name in private_keys):
                key_options = self._get_key_options(private_keys[private_key_name])
                if (not key_options):
                    self._warn('No configured private key types for ', private_key_name, '\n')
                    continue

                key_certificates = private_keys[private_key_name].get('certificates', {})
                revoked_certificates = []
                certificate_count = 0
                for certificate_name in key_certificates:
                    certificate_key_types = self._get_list(key_certificates[certificate_name], 'key_types', key_options.keys())
                    for key_type in certificate_key_types:
                        certificate = self.load_certificate('certificate', certificate_name, key_type)
                        if (certificate):
                            certificate_count += 1
                            try:
                                self.acme_client.revoke(certificate)
                                revoked_certificates.append((certificate_name, key_type))
                                self._status(key_type.upper(), ' certificate ', certificate_name, ' revoked\n')
                            except Exception as error:
                                self._warn('Unable to revoke ', key_type.upper(), ' certificate ', certificate_name, '\n', error, '\n')
                        else:
                            self._warn(key_type.upper(), ' certificate ', certificate_name, ' not found\n')

                archive_date = datetime.datetime.now()
                processed_tlsa = set()
                for certificate_name, key_type in revoked_certificates:
                    self.archive_certificate('certificate', certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_certificate('full_certificate', certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_chain(certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_private_key('full_key', certificate_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                    self.archive_params(certificate_name, archive_name=private_key_name, archive_date=archive_date)
                    ct_submit_logs = self._option_list(key_certificates[certificate_name], 'ct_submit_logs')
                    for ct_log_name in ct_submit_logs:
                        self.archive_sct(certificate_name, key_type, ct_log_name, archive_name=private_key_name, archive_date=archive_date)

                    if (not self._setting('slave_mode')):
                        for zone_name in key_certificates[certificate_name]['alt_names']:
                            if (not self._zone_key(zone_name)):
                                updated_key_zones.add(zone_name)
                    if (certificate_name not in processed_tlsa):
                        processed_tlsa.add(certificate_name)

                        tlsa_records = key_certificates[certificate_name].get('tlsa_records', {})
                        for zone_name in tlsa_records:
                            if (self._zone_key(zone_name)):
                                if (zone_name not in updated_tlsa_zones):
                                    updated_tlsa_zones[zone_name] = []
                                updated_tlsa_zones[zone_name] += self._tlsa_data(self._get_list(tlsa_records, zone_name))
                            else:
                                self._warn('No update key configured for zone ', zone_name, ', unable to remove TLSA records\n')

                if (len(revoked_certificates) == certificate_count):
                    for key_type in key_options:
                        self.archive_private_key('private_key', private_key_name, key_type, archive_name=private_key_name, archive_date=archive_date)
                        self.archive_hpkp_headers(private_key_name, archive_name=private_key_name, archive_date=archive_date)
            else:
                self._warn(private_key_name, ' is not a configured private key\n')

        for zone_name in updated_key_zones:
            self._reload_zone(zone_name)
        for zone_name in updated_tlsa_zones:
            self._remove_tlsa_records(zone_name, self._zone_key(zone_name), updated_tlsa_zones[zone_name])

    def update_tlsa_records(self, private_key_names):
        private_keys = self._config('private_keys')
        tlsa_zones = collections.OrderedDict()

        root_certificates = list(self.load_root_certificates().values())

        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue

            key_options = self._get_key_options(private_keys[private_key_name])
            if (not key_options):
                self._warn('No configured private key types for ', private_key_name, '\n')
                continue

            keys = []
            key_cipher_data = self.key_cipher_data(private_key_name)
            try:
                for key_type in key_options:
                    keys.append((key_type, self.load_private_key('private_key', private_key_name, key_type, key_cipher_data).key))
                    keys.append((key_type, self.load_private_key('backup_key', private_key_name, key_type, key_cipher_data).key))
            except PrivateKeyError as error:
                self._warn('Unable to load private key ', error, '\n')
                continue

            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                tlsa_records = key_certificates[certificate_name].get('tlsa_records', {})
                if (tlsa_records):
                    certificates = []
                    chain = []
                    certificate_key_types = self._get_list(key_certificates[certificate_name], 'key_types', key_options.keys())
                    for key_type in certificate_key_types:
                        certificates.append(self.load_certificate('certificate', certificate_name, key_type))
                        chain += self.load_chain(certificate_name, key_type)

                    for zone_name in tlsa_records:
                        if (self._zone_key(zone_name)):
                            if (zone_name not in tlsa_zones):
                                tlsa_zones[zone_name] = []
                            tlsa_zones[zone_name] += self._tlsa_data(self._get_list(tlsa_records, zone_name), certificates=certificates,
                                                                     chain=(chain + root_certificates),
                                                                     private_keys=[key for key_type, key in keys if (key_type in certificate_key_types)])
                        else:
                            self._warn('No update key configured for zone ', zone_name, ', unable to set TLSA records\n')

        for zone_name in tlsa_zones:
            self._set_tlsa_records(zone_name, self._zone_key(zone_name), tlsa_zones[zone_name])

    def update_signed_certificate_timestamps(self, private_key_names):
        if (not self._directory('sct')):
            return

        private_keys = self._config('private_keys')
        for private_key_name in private_keys:
            if (private_key_names and (private_key_name not in private_key_names)):
                continue

            key_options = self._get_key_options(private_keys[private_key_name])
            if (not key_options):
                self._warn('No configured private key types for ', private_key_name, '\n')
                continue

            transactions = []
            key_certificates = private_keys[private_key_name].get('certificates', {})
            for certificate_name in key_certificates:
                ct_submit_logs = self._option_list(key_certificates[certificate_name], 'ct_submit_logs')
                if (ct_submit_logs):
                    certificate_key_types = self._get_list(key_certificates[certificate_name], 'key_types', key_options.keys())
                    for key_type in certificate_key_types:
                        certificate = self.load_certificate('certificate', certificate_name, key_type)
                        chain = self.load_chain(certificate_name, key_type)
                        for ct_log_name in ct_submit_logs:
                            sct_data = self.fetch_sct(ct_log_name, certificate, chain)
                            if (sct_data):
                                self._note(ct_log_name, ' has SCT for ', key_type.upper(), ' certificate ', certificate_name, ' at ',
                                           self._sct_datetime(sct_data.timestamp).isoformat(), '\n')
                            existing_sct_data = self.load_sct(certificate_name, key_type, ct_log_name)
                            if (sct_data and ((not existing_sct_data) or (sct_data != existing_sct_data))):
                                self._status('Saving Signed Certificate Timestamp for ', key_type.upper(), ' certificate ', certificate_name,
                                             ' from ', ct_log_name, '\n')
                                transactions.append(self.save_sct(certificate_name, key_type, ct_log_name, sct_data))
                                self.update_services(self._get_list(key_certificates[certificate_name], 'services'))

            try:
                self._commit_file_transactions(transactions, archive_name=None)
            except Exception as error:
                self._warn('Unable to save Signed Certificate Timestamps for ', private_key_name, '\n', error, '\n')

    def _process_running(self, pid_file_path):
        try:
            with open(pid_file_path) as pid_file:
                return (-1 < os.getsid(int(pid_file.read())))
        except Exception:
            pass
        return False

    def run(self):
        self._validate_config()
        self._log('\n', self.script_name, ' executed at ', str(datetime.datetime.now()), '\n')
        pid_file_path = os.path.join(self._directory('pid'), self.script_name + '.pid')
        if (self._process_running(pid_file_path)):
            self._error('Client already running\n')
        with self._open_file(pid_file_path, 'w') as pid_file:
            pid_file.write(str(os.getpid()))
        try:
            self.connect_client()
            if (self.args.revoke):
                if (not self.args.private_key_names):
                    self._error('Revocation must explicitly specify private key names\n')
                else:
                    self.revoke_certificates(self.args.private_key_names)
            elif (self.args.auth):
                self.process_authorizations(self.args.private_key_names)
            elif (self.args.tlsa):
                self.update_tlsa_records(self.args.private_key_names)
            elif (self.args.sct):
                self.update_signed_certificate_timestamps(self.args.private_key_names)
            else:
                self.process_authorizations(self.args.private_key_names)
                self.process_certificates(self.args.private_key_names)
                self.update_tlsa_records(self.args.private_key_names)
                self.update_signed_certificate_timestamps(self.args.private_key_names)
            self.reload_services()
            del self.acme_client
        finally:
            os.remove(pid_file_path)


def debug_hook(type, value, tb):
    if hasattr(sys, 'ps1') or not sys.stderr.isatty():
        # we are in interactive mode or we don't have a tty-like
        # device, so we call the default hook
        sys.__excepthook__(type, value, tb)
    else:
        import traceback
        import pdb
        # we are NOT in interactive mode, print the exception...
        traceback.print_exception(type, value, tb)
        print()
        # ...then start the debugger in post-mortem mode.
        pdb.pm()


if __name__ == '__main__':      # called from the command line
    AcmeManager.Run()
